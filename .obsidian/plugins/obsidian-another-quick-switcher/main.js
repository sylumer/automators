/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ts-deepmerge/dist/index.js
var require_dist = __commonJS({
  "node_modules/ts-deepmerge/dist/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var isObject = function(obj) {
      if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
          var prototype = Object.getPrototypeOf(obj);
          return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
      }
      return false;
    };
    var merge3 = function() {
      var objects = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
      }
      return objects.reduce(function(result, current) {
        if (Array.isArray(current)) {
          throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
        }
        Object.keys(current).forEach(function(key) {
          if (["__proto__", "constructor", "prototype"].includes(key)) {
            return;
          }
          if (Array.isArray(result[key]) && Array.isArray(current[key])) {
            result[key] = merge3.options.mergeArrays ? Array.from(new Set(result[key].concat(current[key]))) : current[key];
          } else if (isObject(result[key]) && isObject(current[key])) {
            result[key] = merge3(result[key], current[key]);
          } else {
            result[key] = current[key];
          }
        });
        return result;
      }, {});
    };
    var defaultOptions = {
      mergeArrays: true
    };
    merge3.options = defaultOptions;
    merge3.withOptions = function(options) {
      var objects = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
      }
      merge3.options = __assign({ mergeArrays: true }, options);
      var result = merge3.apply(void 0, __spreadArray([], __read(objects), false));
      merge3.options = defaultOptions;
      return result;
    };
    exports.default = merge3;
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round2 = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round2;
        }
        if (typeof roundingFunction === "function") {
          round2 = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AnotherQuickSwitcher
});
module.exports = __toCommonJS(main_exports);
var import_obsidian13 = require("obsidian");
var import_ts_deepmerge2 = __toESM(require_dist());

// src/app-helper.ts
var import_obsidian = require("obsidian");
var import_ts_deepmerge = __toESM(require_dist());

// src/errors.ts
var ExhaustiveError = class extends Error {
  constructor(value, message = `Unsupported type: ${value}`) {
    super(message);
  }
};

// src/transformer.ts
function autoAliasTransform(input, pattern, format) {
  const _pattern = new RegExp(pattern);
  const match = (value) => _pattern ? Boolean(value.match(_pattern)) : false;
  const replaceByPattern = (value) => _pattern ? value.replace(_pattern, format) : value;
  return match(input) ? replaceByPattern(input) : input;
}

// src/utils/collection-helper.ts
var range = (n) => [...Array(n).keys()];
var mapValues = (obj, to) => Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [key, to(value)])
);
var mapKeys = (obj, to) => Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [to(key), value])
);
var sorter = (toOrdered, order = "asc") => {
  return (a, b) => order === "asc" ? toOrdered(a) > toOrdered(b) ? 1 : toOrdered(b) > toOrdered(a) ? -1 : 0 : toOrdered(a) < toOrdered(b) ? 1 : toOrdered(b) < toOrdered(a) ? -1 : 0;
};
var groupBy = (values, toKey) => {
  const grouped = {};
  for (const value of values) {
    const key = toKey(value);
    if (!grouped[key]) {
      grouped[key] = [];
    }
    grouped[key].push(value);
  }
  return grouped;
};
var keyBy = (values, toKey) => {
  const indexing = {};
  for (const value of values) {
    const key = toKey(value);
    indexing[key] = value;
  }
  return indexing;
};
var count = (values) => {
  const ret = {};
  for (const value of values) {
    if (ret[value]) {
      ret[value]++;
    } else {
      ret[value] = 1;
    }
  }
  return ret;
};
function flatten(matrix) {
  return matrix.reduce((a, c) => {
    a.push(...c);
    return a;
  }, []);
}
function uniq(values) {
  return [...new Set(values)];
}
function uniqBy(values, fn) {
  const m = /* @__PURE__ */ new Map();
  for (const x of values) {
    const k = fn(x);
    if (!m.has(k)) {
      m.set(k, x);
    }
  }
  return Array.from(m.values());
}
function uniqFlatMap(values, mapper) {
  return uniq(flatten(values.map(mapper)));
}
function intersection(matrix) {
  return matrix.length === 0 ? [] : matrix.reduce((acc, xs) => acc.filter((x) => xs.includes(x)));
}
var minBy = (collection, toNum) => {
  const select = (a, b) => toNum(a) <= toNum(b) ? a : b;
  return collection.reduce(select);
};
function includeItems(items, patterns, toPath) {
  return patterns.length === 0 ? items : items.filter((x) => patterns.some((p) => toPath(x).startsWith(p)));
}
function excludeItems(items, patterns, toPath) {
  return patterns.length === 0 ? items : items.filter((x) => !patterns.some((p) => toPath(x).startsWith(p)));
}
function equalsAsSet(ary1, ary2) {
  return [...ary1].sort().join() === [...ary2].sort().join();
}
function mirrorMap(collection, toValue) {
  return collection.reduce(
    (p, c) => {
      const v = toValue(c);
      p[v] = v;
      return p;
    },
    {}
  );
}
function mirror(collection) {
  return mirrorMap(collection, (x) => x);
}
function omitBy(obj, shouldOmit) {
  const cloned = { ...obj };
  for (const [k, v] of Object.entries(cloned)) {
    if (shouldOmit(k, v)) {
      delete cloned[k];
    }
  }
  return cloned;
}

// src/utils/path.ts
function basename(path, ext) {
  var _a, _b;
  const name = (_b = (_a = path.match(/.+[\\/]([^\\/]+)[\\/]?$/)) == null ? void 0 : _a[1]) != null ? _b : path;
  return ext && name.endsWith(ext) ? name.replace(ext, "") : name;
}
function extname(path) {
  const ext = basename(path).split(".").slice(1).pop();
  return ext ? `.${ext}` : "";
}
function dirname(path) {
  var _a, _b;
  return (_b = (_a = path.match(/(.+)[\\/].+$/)) == null ? void 0 : _a[1]) != null ? _b : ".";
}
function normalizePath(path) {
  return path.replace(/\\/g, "/").replace(/\/+/g, "/");
}
function normalizeRelativePath(path, base) {
  const sep = /[\\/]/;
  let es = [];
  path.split(sep).forEach((x, i) => {
    if (i === 0 && x === ".") {
      es = base.split("/");
      return;
    }
    if (x === "..") {
      if (i === 0) {
        es = base.split("/");
      }
      es = dirname(es.join("/")).split("/").filter((x2) => x2 !== ".");
      return;
    }
    es = [...es, x];
  });
  const r = es.filter((x) => x !== "").join("/");
  return base[0] === "/" ? `/${r}` : r;
}
function isExcalidraw(file) {
  if (!file) {
    return false;
  }
  return file.path.endsWith(".excalidraw.md") || // old version
  file.path.endsWith(".excalidraw");
}

// src/utils/diacritics-map.ts
var defaultDiacriticsRemovalMap = [
  {
    base: "A",
    letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
  },
  { base: "AA", letters: "\uA732" },
  { base: "AE", letters: "\xC6\u01FC\u01E2" },
  { base: "AO", letters: "\uA734" },
  { base: "AU", letters: "\uA736" },
  { base: "AV", letters: "\uA738\uA73A" },
  { base: "AY", letters: "\uA73C" },
  {
    base: "B",
    letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
  },
  {
    base: "C",
    letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
  },
  {
    base: "D",
    letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779\xD0"
  },
  { base: "DZ", letters: "\u01F1\u01C4" },
  { base: "Dz", letters: "\u01F2\u01C5" },
  {
    base: "E",
    letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
  },
  { base: "F", letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B" },
  {
    base: "G",
    letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
  },
  {
    base: "H",
    letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
  },
  {
    base: "I",
    letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
  },
  { base: "J", letters: "J\u24BF\uFF2A\u0134\u0248" },
  {
    base: "K",
    letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
  },
  {
    base: "L",
    letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
  },
  { base: "LJ", letters: "\u01C7" },
  { base: "Lj", letters: "\u01C8" },
  { base: "M", letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C" },
  {
    base: "N",
    letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
  },
  { base: "NJ", letters: "\u01CA" },
  { base: "Nj", letters: "\u01CB" },
  {
    base: "O",
    letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
  },
  { base: "OI", letters: "\u01A2" },
  { base: "OO", letters: "\uA74E" },
  { base: "OU", letters: "\u0222" },
  { base: "OE", letters: "\x8C\u0152" },
  { base: "oe", letters: "\x9C\u0153" },
  {
    base: "P",
    letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
  },
  { base: "Q", letters: "Q\u24C6\uFF31\uA756\uA758\u024A" },
  {
    base: "R",
    letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
  },
  {
    base: "S",
    letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
  },
  {
    base: "T",
    letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
  },
  { base: "TZ", letters: "\uA728" },
  {
    base: "U",
    letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
  },
  { base: "V", letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245" },
  { base: "VY", letters: "\uA760" },
  {
    base: "W",
    letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
  },
  { base: "X", letters: "X\u24CD\uFF38\u1E8A\u1E8C" },
  {
    base: "Y",
    letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
  },
  {
    base: "Z",
    letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
  },
  {
    base: "a",
    letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
  },
  { base: "aa", letters: "\uA733" },
  { base: "ae", letters: "\xE6\u01FD\u01E3" },
  { base: "ao", letters: "\uA735" },
  { base: "au", letters: "\uA737" },
  { base: "av", letters: "\uA739\uA73B" },
  { base: "ay", letters: "\uA73D" },
  {
    base: "b",
    letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
  },
  {
    base: "c",
    letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
  },
  {
    base: "d",
    letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
  },
  { base: "dz", letters: "\u01F3\u01C6" },
  {
    base: "e",
    letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
  },
  { base: "f", letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C" },
  {
    base: "g",
    letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
  },
  {
    base: "h",
    letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
  },
  { base: "hv", letters: "\u0195" },
  {
    base: "i",
    letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
  },
  { base: "j", letters: "j\u24D9\uFF4A\u0135\u01F0\u0249" },
  {
    base: "k",
    letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
  },
  {
    base: "l",
    letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
  },
  { base: "lj", letters: "\u01C9" },
  { base: "m", letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F" },
  {
    base: "n",
    letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
  },
  { base: "nj", letters: "\u01CC" },
  {
    base: "o",
    letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
  },
  { base: "oi", letters: "\u01A3" },
  { base: "ou", letters: "\u0223" },
  { base: "oo", letters: "\uA74F" },
  {
    base: "p",
    letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
  },
  { base: "q", letters: "q\u24E0\uFF51\u024B\uA757\uA759" },
  {
    base: "r",
    letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
  },
  {
    base: "s",
    letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
  },
  {
    base: "t",
    letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
  },
  { base: "tz", letters: "\uA729" },
  {
    base: "u",
    letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
  },
  { base: "v", letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C" },
  { base: "vy", letters: "\uA761" },
  {
    base: "w",
    letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
  },
  { base: "x", letters: "x\u24E7\uFF58\u1E8B\u1E8D" },
  {
    base: "y",
    letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
  },
  {
    base: "z",
    letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
  },
  // Added to original source definitions
  // https://github.com/tadashi-aikawa/obsidian-another-quick-switcher/issues/131
  {
    base: "2",
    letters: "\xB2"
  },
  {
    base: "3",
    letters: "\xB3"
  }
];
var diacriticsMap = {};
for (let i = 0; i < defaultDiacriticsRemovalMap.length; i++) {
  const letters = defaultDiacriticsRemovalMap[i].letters;
  for (let j = 0; j < letters.length; j++) {
    diacriticsMap[letters[j]] = defaultDiacriticsRemovalMap[i].base;
  }
}
var diacritics_map_default = diacriticsMap;

// src/utils/strings.ts
var regEmoji = new RegExp(
  // biome-ignore lint/suspicious/noMisleadingCharacterClass: <explanation>
  /[\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF]|[\uFE0E-\uFE0F]/,
  "g"
);
function excludeSpace(text) {
  return text.replace(/ /g, "");
}
function excludeEmoji(text) {
  return text.replace(regEmoji, "");
}
function normalizeAccentsDiacritics(text) {
  return text.replace(/[^\u0000-\u007E]/g, (x) => {
    var _a;
    return (_a = diacritics_map_default[x]) != null ? _a : x;
  });
}
function normalize(str, isNormalizeAccentsDiacritics) {
  const t = str.toLowerCase();
  return isNormalizeAccentsDiacritics ? normalizeAccentsDiacritics(t) : t;
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^=!:${}()|[\]\/\\]/g, "\\$&");
}
function includes(text, query, isNormalizeAccentsDiacritics) {
  return normalize(text, isNormalizeAccentsDiacritics).includes(
    normalize(query, isNormalizeAccentsDiacritics)
  );
}
function capitalIncludes(text, query, isNormalizeAccentsDiacritics) {
  if (!hasCapitalLetter(query)) {
    return includes(text, query, isNormalizeAccentsDiacritics);
  }
  return isNormalizeAccentsDiacritics ? normalizeAccentsDiacritics(text).includes(
    normalizeAccentsDiacritics(query)
  ) : text.includes(query);
}
function smartIncludes(text, query, isNormalizeAccentsDiacritics) {
  return excludeSpace(normalize(text, isNormalizeAccentsDiacritics)).includes(
    excludeSpace(normalize(query, isNormalizeAccentsDiacritics))
  );
}
function smartStartsWith(text, query, isNormalizeAccentsDiacritics) {
  return excludeSpace(
    excludeEmoji(normalize(text, isNormalizeAccentsDiacritics))
  ).startsWith(excludeSpace(normalize(query, isNormalizeAccentsDiacritics)));
}
function smartEquals(text, query, isNormalizeAccentsDiacritics) {
  return excludeSpace(
    excludeEmoji(normalize(text, isNormalizeAccentsDiacritics))
  ) === normalize(query, isNormalizeAccentsDiacritics);
}
function excludeFormat(text) {
  return text.replace(/\[\[[^\]]+\|(.*?)]]/g, "$1").replace(/\[\[([^\]]+)]]/g, "$1").replace(/\[([^\]]+)]\(https?[^)]+\)/g, "$1").replace(/\[([^\]]+)]/g, "$1").replace(/`([^`]+)`/g, "$1").replace(/~~([^~]+)~~/g, "$1").replace(/==([^=]+)==/g, "$1").replace(/\*\*([^*]+)\*\*/g, "$1").replace(/\*([^*]+)\*/g, "$1").replace(/__([^_]+)__/g, "$1").replace(/_([^_]+)_/g, "$1").replace(/<[^>]+>([^<]+)<\/[^>]+>/g, "$1");
}
function smartCommaSplit(text) {
  return text.split(",").filter((x) => x);
}
function smartLineBreakSplit(text) {
  return text.split("\n").filter((x) => x);
}
function smartWhitespaceSplit(text) {
  const strs = [];
  let str = "";
  let hasQuote = false;
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    switch (ch) {
      case `"`:
        hasQuote = !hasQuote;
        break;
      case " ":
        if (hasQuote) {
          str += ch;
        } else {
          strs.push(str);
          str = "";
        }
        break;
      default:
        str += ch;
    }
  }
  strs.push(str);
  return strs.filter((x) => x);
}
function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function hasCapitalLetter(str) {
  return str.toLowerCase() !== str;
}
function microFuzzy(value, query) {
  if (value.startsWith(query)) {
    return { type: "starts-with", score: 2 ** query.length / value.length };
  }
  const emojiLessValue = excludeEmoji(value);
  if (emojiLessValue.startsWith(query)) {
    return { type: "starts-with", score: 2 ** query.length / value.length };
  }
  if (value.includes(query)) {
    return { type: "includes", score: 2 ** query.length / value.length };
  }
  let i = 0;
  let scoreSeed = 0;
  let combo = 0;
  for (let j = 0; j < emojiLessValue.length; j++) {
    if (emojiLessValue[j] === query[i]) {
      combo++;
      i++;
    } else {
      if (combo > 0) {
        scoreSeed += 2 ** combo;
        combo = 0;
      }
    }
    if (i === query.length) {
      if (combo > 0) {
        scoreSeed += 2 ** combo;
      }
      return { type: "fuzzy", score: scoreSeed / value.length };
    }
  }
  return { type: "none", score: 0 };
}
function smartMicroFuzzy(text, query, isNormalizeAccentsDiacritics) {
  return microFuzzy(
    excludeSpace(normalize(text, isNormalizeAccentsDiacritics)),
    excludeSpace(normalize(query, isNormalizeAccentsDiacritics))
  );
}
function trimLineByEllipsis(text, max) {
  return text.length > max * 2 ? `${text.slice(0, max)} ... ${text.slice(text.length - max)}` : text;
}

// src/app-helper.ts
function isFrontMatterLinkCache(x) {
  return x.position == null;
}
var AppHelper = class {
  constructor(app) {
    this.unsafeApp = app;
  }
  getActiveFile() {
    return this.unsafeApp.workspace.getActiveFile();
  }
  getViewInActiveLeaf() {
    return this.unsafeApp.workspace.getActiveViewOfType(import_obsidian.View);
  }
  getFileViewInActiveLeaf() {
    return this.unsafeApp.workspace.getActiveViewOfType(import_obsidian.FileView);
  }
  getMarkdownViewInActiveLeaf() {
    return this.unsafeApp.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  }
  getCanvasViewInActiveLeaf() {
    return this.getViewInActiveLeaf();
  }
  getCurrentEditor() {
    var _a, _b;
    return (_b = (_a = this.getMarkdownViewInActiveLeaf()) == null ? void 0 : _a.editor) != null ? _b : null;
  }
  getCurrentDirPath() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.getActiveFile()) == null ? void 0 : _a.parent) == null ? void 0 : _b.path) != null ? _c : "";
  }
  getCurrentOffset() {
    var _a;
    const editor = this.getCurrentEditor();
    if (!editor) {
      return null;
    }
    const cursor = (_a = this.getCurrentEditor()) == null ? void 0 : _a.getCursor();
    if (!cursor) {
      return null;
    }
    return editor.posToOffset(cursor);
  }
  getHeadersInActiveFile() {
    var _a, _b;
    const activeFile = this.getActiveFile();
    if (!activeFile) {
      return [];
    }
    return (_b = (_a = this.unsafeApp.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.headings) != null ? _b : [];
  }
  getFolders() {
    return this.unsafeApp.vault.getAllLoadedFiles().filter((x) => x instanceof import_obsidian.TFolder);
  }
  getLayout() {
    return this.unsafeApp.workspace.getLayout();
  }
  getLeftSideBarWidth() {
    return this.getLayout().left.collapsed ? 0 : this.getLayout().left.width;
  }
  getRightSideBarWidth() {
    return this.getLayout().right.collapsed ? 0 : this.getLayout().right.width;
  }
  async findExternalLinkUrls(file) {
    const content = await this.unsafeApp.vault.read(file);
    const matches = Array.from(content.matchAll(/https?:\/\/[^ \n)]+/g));
    return matches.map((x) => x[0]);
  }
  findFirstLinkOffset(file, linkFile) {
    var _a, _b, _c;
    const fileCache = this.unsafeApp.metadataCache.getFileCache(
      file
    );
    const links = (_a = fileCache == null ? void 0 : fileCache.links) != null ? _a : [];
    const frontmatterLinks = (_b = fileCache == null ? void 0 : fileCache.frontmatterLinks) != null ? _b : [];
    const embeds = (_c = fileCache == null ? void 0 : fileCache.embeds) != null ? _c : [];
    const first = [...links, ...frontmatterLinks, ...embeds].find(
      (x) => {
        var _a2;
        const firstLinkPath = this.isPhantomFile(linkFile) ? this.getPathToBeCreated(x.link) : (_a2 = this.unsafeApp.metadataCache.getFirstLinkpathDest(
          (0, import_obsidian.getLinkpath)(x.link),
          file.path
        )) == null ? void 0 : _a2.path;
        return firstLinkPath === linkFile.path;
      }
    );
    if (!first || isFrontMatterLinkCache(first)) {
      return 0;
    }
    return first.position.start.offset;
  }
  findFirstHeaderOffset(file, header) {
    var _a, _b;
    const cache = this.unsafeApp.metadataCache.getFileCache(file);
    if (!cache) {
      return null;
    }
    const target = (_a = cache.headings) == null ? void 0 : _a.find(
      (x) => excludeFormat(x.heading) === excludeFormat(header)
    );
    return (_b = target == null ? void 0 : target.position.start.offset) != null ? _b : null;
  }
  getBacklinksByFilePathInActiveFile() {
    const f = this.getActiveFile();
    if (!f) {
      return null;
    }
    return Object.fromEntries(
      this.unsafeApp.metadataCache.getBacklinksForFile(f).data
    );
  }
  // noinspection FunctionWithMultipleLoopsJS
  /**
   * Includes phantom files
   */
  createBacklinksMap() {
    const backLinksMap = {};
    const unresolvedLinks = mapValues(
      this.unsafeApp.metadataCache.unresolvedLinks,
      (innerMap) => mapKeys(innerMap, (x) => this.getPathToBeCreated(x))
    );
    for (const [filePath, linkMap] of Object.entries(
      (0, import_ts_deepmerge.default)(this.unsafeApp.metadataCache.resolvedLinks, unresolvedLinks)
    )) {
      for (const linkPath of Object.keys(linkMap)) {
        if (!backLinksMap[linkPath]) {
          backLinksMap[linkPath] = /* @__PURE__ */ new Set();
        }
        backLinksMap[linkPath].add(filePath);
      }
    }
    return backLinksMap;
  }
  /**
   * @return {"<relative path from root>: UnsafeLinkCache"}
   */
  createLinksMap(file) {
    var _a, _b, _c;
    const cache = this.unsafeApp.metadataCache.getFileCache(
      file
    );
    return mapValues(
      groupBy(
        [
          ...(_a = cache == null ? void 0 : cache.embeds) != null ? _a : [],
          ...(_b = cache == null ? void 0 : cache.links) != null ? _b : [],
          ...(_c = cache == null ? void 0 : cache.frontmatterLinks) != null ? _c : []
        ],
        (x) => {
          var _a2;
          return (_a2 = this.linkText2Path(x.link)) != null ? _a2 : this.getPathToBeCreated(x.link);
        }
      ),
      (caches) => caches[0]
    );
  }
  getLinksByFilePathInActiveFile() {
    var _a, _b, _c;
    const file = this.getActiveFile();
    if (!file) {
      return null;
    }
    const cache = this.unsafeApp.metadataCache.getFileCache(
      file
    );
    return groupBy(
      [
        ...(_a = cache == null ? void 0 : cache.embeds) != null ? _a : [],
        ...(_b = cache == null ? void 0 : cache.links) != null ? _b : [],
        ...(_c = cache == null ? void 0 : cache.frontmatterLinks) != null ? _c : []
      ],
      (x) => {
        var _a2;
        return (_a2 = this.linkText2Path(x.link)) != null ? _a2 : this.getPathToBeCreated(x.link);
      }
    );
  }
  async moveTo(to, editor) {
    var _a;
    const isToOffset = typeof to === "number";
    const activeFile = this.getActiveFile();
    const activeLeaf = this.unsafeApp.workspace.activeLeaf;
    if (!activeFile || !activeLeaf) {
      return;
    }
    const subView = (_a = this.getMarkdownViewInActiveLeaf()) == null ? void 0 : _a.currentMode;
    if (!subView) {
      return;
    }
    const targetEditor = editor != null ? editor : this.getCurrentEditor();
    if (!targetEditor) {
      return;
    }
    const line = isToOffset ? targetEditor.offsetToPos(to).line : to.start.line;
    targetEditor.setCursor(
      targetEditor.offsetToPos(isToOffset ? to : to.start.offset)
    );
    await activeLeaf.openFile(activeFile, {
      eState: {
        line
      },
      active: false
    });
  }
  getFileByPath(path) {
    const abstractFile = this.unsafeApp.vault.getAbstractFileByPath(path);
    if (!abstractFile) {
      return null;
    }
    return abstractFile;
  }
  getFilePathsInActiveWindow() {
    return this.unsafeApp.workspace.getLeavesOfType("markdown").filter(
      (x) => {
        var _a;
        return x.getContainer() === ((_a = this.unsafeApp.workspace.activeLeaf) == null ? void 0 : _a.getContainer());
      }
    ).map((x) => x.getViewState().state.file);
  }
  captureState(initialLeaf) {
    const currentLeaf = this.unsafeApp.workspace.getLeaf();
    const newLeaf = this.unsafeApp.workspace.getLeaf();
    const newState = newLeaf.getViewState();
    const newEState = newLeaf.getEphemeralState();
    const unsafeApp = this.unsafeApp;
    return {
      leaf: newLeaf,
      async restore() {
        if (!newLeaf) {
          return;
        }
        if (!initialLeaf || initialLeaf.getViewState().pinned) {
          newLeaf.detach();
        } else {
          await newLeaf.setViewState(
            {
              ...newState,
              active: newLeaf === currentLeaf,
              popstate: true
            },
            newEState
          );
          if (newLeaf !== currentLeaf) {
            unsafeApp.workspace.setActiveLeaf(currentLeaf, { focus: true });
          }
        }
        this.leaf = void 0;
      }
    };
  }
  getOpenState(leaf, file) {
    let type = this.unsafeApp.viewRegistry.getTypeByExtension(file.extension);
    if (leaf.view instanceof import_obsidian.FileView && leaf.view.canAcceptExtension(file.extension)) {
      type = leaf.view.getViewType();
    }
    return { type, state: { file: file.path } };
  }
  findLeaf(file) {
    return this.unsafeApp.workspace.getLeavesOfType("markdown").find((x) => x.getViewState().state.file === file.path);
  }
  async openFile(file, option = {}, captureState) {
    var _a, _b, _c;
    const opt = {
      ...{ leafType: "same-tab", inplace: false },
      ...option
    };
    const priorLeaf = (option == null ? void 0 : option.preventDuplicateTabs) ? this.findLeaf(file) : void 0;
    let leaf;
    let background = false;
    switch (opt.leafType) {
      case "same-tab":
        leaf = (_b = (_a = option.leafPriorToSameTab) != null ? _a : captureState == null ? void 0 : captureState.leaf) != null ? _b : this.unsafeApp.workspace.getLeaf();
        break;
      case "new-tab":
        leaf = priorLeaf != null ? priorLeaf : this.unsafeApp.workspace.getLeaf(true);
        break;
      case "new-tab-background":
        leaf = priorLeaf != null ? priorLeaf : this.unsafeApp.workspace.getLeaf(true);
        background = true;
        break;
      case "new-pane-horizontal":
        leaf = this.unsafeApp.workspace.getLeaf("split", "horizontal");
        break;
      case "new-pane-vertical":
        leaf = this.unsafeApp.workspace.getLeaf("split", "vertical");
        break;
      case "new-window":
        leaf = this.unsafeApp.workspace.openPopoutLeaf();
        break;
      case "popup": {
        const hoverEditorInstance = this.unsafeApp.plugins.plugins["obsidian-hover-editor"];
        leaf = (_c = hoverEditorInstance == null ? void 0 : hoverEditorInstance.spawnPopover()) != null ? _c : this.unsafeApp.workspace.getLeaf(true);
        break;
      }
      default:
        throw new ExhaustiveError(opt.leafType);
    }
    if (opt.inplace && opt.leafType === "same-tab") {
      await leaf.setViewState({
        ...leaf.getViewState(),
        active: !background,
        popstate: true,
        ...this.getOpenState(leaf, file)
      });
    } else {
      await leaf.openFile(file, {
        ...leaf.getViewState(),
        active: !background
      });
    }
    if (leaf.view instanceof import_obsidian.MarkdownView) {
      const markdownView = leaf.view;
      if (opt.offset != null) {
        this.moveTo(opt.offset, markdownView.editor);
      } else if (opt.line != null) {
        const p = { line: opt.line, offset: 0, col: 0 };
        this.moveTo({ start: p, end: p }, markdownView.editor);
      }
    }
  }
  openFileInDefaultApp(file) {
    this.unsafeApp.openWithDefaultApp(file.path);
  }
  openFolderInDefaultApp(folder) {
    this.unsafeApp.openWithDefaultApp(folder.path);
  }
  openInSystemExplorer(entry) {
    this.unsafeApp.showInFolder(entry.path);
  }
  closeFile(file) {
    const targetLeaves = this.unsafeApp.workspace.getLeavesOfType("markdown").filter((x) => {
      var _a;
      return ((_a = x.getViewState().state) == null ? void 0 : _a.file) === file.path;
    });
    for (const leaf of targetLeaves) {
      leaf.detach();
    }
  }
  // FIXME: function name
  getStarredFilePaths() {
    return this.unsafeApp.internalPlugins.plugins.bookmarks.instance.getBookmarks().map((x) => x.type === "file" ? x.path : void 0).filter((x) => x !== void 0);
  }
  searchPhantomFiles() {
    return uniq(
      flatten(
        Object.values(this.unsafeApp.metadataCache.unresolvedLinks).map(
          Object.keys
        )
      )
    ).map((x) => this.createPhantomFile(x));
  }
  insertStringToActiveFile(str) {
    const activeMarkdownView = this.unsafeApp.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeMarkdownView) {
      return;
    }
    const editor = activeMarkdownView.editor;
    editor.replaceSelection(str);
  }
  insertLinkToActiveFileBy(file, opts) {
    var _a;
    const activeMarkdownView = this.unsafeApp.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!(activeMarkdownView == null ? void 0 : activeMarkdownView.file)) {
      return;
    }
    let linkText = this.unsafeApp.fileManager.generateMarkdownLink(
      file,
      activeMarkdownView.file.path
    );
    const displayedString = opts == null ? void 0 : opts.displayedString;
    const transformer = opts == null ? void 0 : opts.aliasTranformer;
    if (this.unsafeApp.vault.config.useMarkdownLinks) {
      const { text, link } = Array.from(
        linkText.matchAll(/\[(?<text>[^\]]+)]\((?<link>.+)\)/g)
      )[0].groups;
      let dispTxt = displayedString != null ? displayedString : text;
      if (transformer) {
        dispTxt = autoAliasTransform(
          dispTxt,
          transformer.pattern,
          transformer.format
        );
      }
      linkText = `[${dispTxt}](${link})`;
    } else {
      const text = (_a = Array.from(linkText.matchAll(/\[\[(?<text>[^\]]+)]]/g))[0].groups) == null ? void 0 : _a.text;
      let dispTxt = displayedString != null ? displayedString : text;
      if (transformer) {
        dispTxt = autoAliasTransform(
          dispTxt,
          transformer.pattern,
          transformer.format
        );
      }
      linkText = text === dispTxt ? `[[${text}]]` : `[[${text}|${dispTxt}]]`;
    }
    if (opts == null ? void 0 : opts.phantom) {
      linkText = linkText.replace(/\[\[.*\/([^\]]+)]]/, "[[$1]]");
    }
    const editor = activeMarkdownView.editor;
    editor.replaceSelection(
      // XXX: dirty hack
      linkText.endsWith(".excalidraw]]") ? `!${linkText}` : (
        // ![[hoge.pdf]] -> [[hoge.pdf]]
        linkText.endsWith(".pdf]]") ? linkText.replace("!", "") : linkText
      )
    );
  }
  async createMarkdown(linkText) {
    const linkPath = this.getPathToBeCreated(linkText);
    if (await this.exists(linkPath)) {
      return null;
    }
    const dir = dirname(linkPath);
    if (!await this.exists(dir)) {
      await this.unsafeApp.vault.createFolder(dir);
    }
    return this.unsafeApp.vault.create(linkPath, "");
  }
  exists(normalizedPath) {
    return this.unsafeApp.vault.adapter.exists(normalizedPath);
  }
  isPopWindow() {
    return !fish(".modal-bg");
  }
  removeCommand(commandId) {
    this.unsafeApp.commands.removeCommand(commandId);
  }
  getCommandIds(manifestId) {
    return Object.keys(this.unsafeApp.commands.commands).filter(
      (x) => x.startsWith(manifestId)
    );
  }
  getPathToBeCreated(linkText) {
    var _a, _b, _c;
    let linkPath = (0, import_obsidian.getLinkpath)(linkText);
    if (extname(linkPath) !== ".md") {
      linkPath += ".md";
    }
    if (linkPath.includes("/")) {
      return linkPath;
    }
    switch (this.unsafeApp.vault.config.newFileLocation) {
      case "root":
        return `/${linkPath}`;
      case "current":
        return `${(_c = (_b = (_a = this.getActiveFile()) == null ? void 0 : _a.parent) == null ? void 0 : _b.path) != null ? _c : ""}/${linkPath}`;
      case "folder":
        return `${this.unsafeApp.vault.config.newFileFolderPath}/${linkPath}`;
      default:
        return `/${linkPath}`;
    }
  }
  linkText2Path(linkText) {
    var _a, _b;
    const activeFile = this.getActiveFile();
    if (!activeFile) {
      return null;
    }
    return (_b = (_a = this.unsafeApp.metadataCache.getFirstLinkpathDest(
      linkText,
      activeFile.path
    )) == null ? void 0 : _a.path) != null ? _b : null;
  }
  isPhantomFile(file) {
    return file.stat.ctime === 0;
  }
  isActiveLeafCanvas() {
    var _a;
    return ((_a = this.getViewInActiveLeaf()) == null ? void 0 : _a.getViewType()) === "canvas";
  }
  // XXX: not strict
  isCacheInitialized() {
    return this.unsafeApp.metadataCache.initialized;
  }
  addFileToCanvas(file, offset = { x: 0, y: 0 }) {
    const unsafeView = this.getCanvasViewInActiveLeaf();
    const { x, y } = unsafeView.canvas.posCenter();
    return unsafeView.canvas.createFileNode({
      file,
      pos: { x: x + offset.x, y: y + offset.y }
    });
  }
  enableFileExplorer() {
    return this.unsafeApp.internalPlugins.getEnabledPluginById("file-explorer");
  }
  revealInFolder(folder) {
    this.unsafeApp.internalPlugins.plugins["file-explorer"].instance.revealInFolder(folder);
  }
  // TODO: Use another interface instead of TFile
  createPhantomFile(linkText) {
    const linkPath = this.getPathToBeCreated(linkText);
    return {
      path: linkPath,
      name: basename(linkPath),
      vault: this.unsafeApp.vault,
      extension: "md",
      basename: basename(linkPath, ".md"),
      parent: {
        name: basename(dirname(linkPath)),
        path: dirname(linkPath),
        vault: this.unsafeApp.vault,
        // XXX: From here, Untrusted properties
        children: [],
        // @ts-ignore
        parent: null,
        isRoot: () => true
      },
      stat: {
        mtime: 0,
        ctime: 0,
        size: 0
      }
    };
  }
};

// src/commands.ts
var import_obsidian12 = require("obsidian");

// src/ui/AnotherQuickSwitcherModal.ts
var import_obsidian4 = require("obsidian");

// src/keys.ts
var import_obsidian2 = require("obsidian");
var MOD = import_obsidian2.Platform.isMacOS ? "Cmd" : "Ctrl";
var ALT = import_obsidian2.Platform.isMacOS ? "Option" : "Alt";
var quickResultSelectionModifier = (userAltInsteadOfModForQuickResultSelection) => userAltInsteadOfModForQuickResultSelection ? ALT : MOD;
function hotkey2String(hotkey) {
  if (!hotkey) {
    return "";
  }
  const mods = hotkey.modifiers.join(" ");
  return mods ? `${mods} ${hotkey.key}` : hotkey.key;
}
function string2Hotkey(hotKey, hideHotkeyGuide) {
  const keys = hotKey.split(" ");
  if (keys.length === 1) {
    return keys[0] === "" ? null : { modifiers: [], key: keys[0], hideHotkeyGuide };
  }
  return {
    modifiers: keys.slice(0, -1),
    key: keys.at(-1),
    hideHotkeyGuide
  };
}
function createInstructions(hotkeysByCommand) {
  return Object.keys(hotkeysByCommand).filter((x) => hotkeysByCommand[x].length > 0).map((x) => createInstruction(x, hotkeysByCommand[x][0])).filter((x) => x !== null);
}
function createInstruction(commandName, hotkey) {
  if (!hotkey || hotkey.hideHotkeyGuide) {
    return null;
  }
  const mods = hotkey.modifiers.map((x) => x === "Mod" ? MOD : x === "Alt" ? ALT : x).join(" ");
  const key = hotkey.key === "Enter" ? "\u21B5" : hotkey.key === "ArrowUp" ? "\u2191" : hotkey.key === "ArrowDown" ? "\u2193" : hotkey.key === "Escape" ? "ESC" : hotkey.key;
  const command = mods ? `[${mods} ${key}]` : `[${key}]`;
  return { command, purpose: commandName };
}
function equalsAsHotkey(hotkey, keyDownEvent) {
  const hk = {
    modifiers: [],
    key: normalizeHotkeyEventKey(keyDownEvent.key)
  };
  if (keyDownEvent.shiftKey) {
    hk.modifiers.push("Shift");
  }
  if (keyDownEvent.altKey) {
    hk.modifiers.push("Alt");
  }
  if (keyDownEvent.ctrlKey) {
    hk.modifiers.push(import_obsidian2.Platform.isMacOS ? "Ctrl" : "Mod");
  }
  if (keyDownEvent.metaKey) {
    hk.modifiers.push(import_obsidian2.Platform.isMacOS ? "Mod" : "Meta");
  }
  return hotkey.key.toLowerCase() === hk.key.toLowerCase() && equalsAsSet(hotkey.modifiers, hk.modifiers);
}
function normalizeHotkeyEventKey(key) {
  return key === " " ? "Space" : key;
}
function normalizeKey(hotkey) {
  return hotkey === "Space" ? " " : hotkey;
}

// src/utils/types.ts
function isPresent(arg) {
  return arg != null;
}

// src/matcher.ts
function matchQuery(item, query, options) {
  var _a;
  const {
    searchByTags,
    searchByHeaders,
    searchByLinks,
    keysOfPropertyToSearch,
    isNormalizeAccentsDiacritics
  } = options;
  if (searchByTags && query.startsWith("#")) {
    const tags = item.tags.filter(
      (tag) => smartIncludes(tag.slice(1), query.slice(1), isNormalizeAccentsDiacritics)
    );
    return [
      {
        type: tags.length > 0 ? "tag" : "not found",
        meta: tags,
        query
      }
    ];
  }
  const qs = query.split("/");
  const file = qs.pop();
  const dirs = qs;
  const includeDir = dirs.every(
    (dir) => {
      var _a2;
      return smartIncludes((_a2 = item.file.parent) == null ? void 0 : _a2.path, dir, isNormalizeAccentsDiacritics);
    }
  );
  if (!includeDir) {
    return [{ type: "not found", query }];
  }
  if (file.length === 0) {
    return [{ type: "directory", meta: [item.file.path], query }];
  }
  const results = [];
  if (item.tokens.some((t) => smartEquals(t, file, isNormalizeAccentsDiacritics))) {
    results.push({ type: "word-perfect", meta: [item.file.name], query });
  }
  const fuzzyResult = smartMicroFuzzy(
    item.file.extension === "md" ? item.file.basename : item.file.name,
    // Should calculate the score without .md
    query,
    isNormalizeAccentsDiacritics
  );
  switch (fuzzyResult.type) {
    case "starts-with":
      results.push({ type: "prefix-name", meta: [item.file.name], query });
    case "includes":
      results.push({ type: "name", meta: [item.file.name], query });
    case "fuzzy":
      if (options.fuzzyTarget) {
        if (fuzzyResult.score > options.minFuzzyScore) {
          results.push({
            type: "fuzzy-name",
            meta: [item.file.name],
            query,
            score: fuzzyResult.score
          });
        }
      }
  }
  const prefixNameMatchedAliases = [];
  const nameMatchedAliases = [];
  const fuzzyNameMatchedAliases = [];
  for (const al of item.aliases) {
    const r = smartMicroFuzzy(al, file, isNormalizeAccentsDiacritics);
    switch (r.type) {
      case "starts-with":
        prefixNameMatchedAliases.push(al);
      case "includes":
        nameMatchedAliases.push(al);
      case "fuzzy":
        if (options.fuzzyTarget) {
          if (r.score > options.minFuzzyScore) {
            fuzzyNameMatchedAliases.push({
              value: al,
              score: r.score
            });
          }
        }
    }
  }
  if (prefixNameMatchedAliases.length > 0) {
    results.push({
      type: "prefix-name",
      meta: prefixNameMatchedAliases,
      alias: minBy(prefixNameMatchedAliases, (x) => x.length),
      query
    });
  }
  if (nameMatchedAliases.length > 0) {
    results.push({
      type: "name",
      meta: nameMatchedAliases,
      alias: minBy(nameMatchedAliases, (x) => x.length),
      query
    });
  }
  if (options.fuzzyTarget && fuzzyNameMatchedAliases.length > 0) {
    const m = minBy(fuzzyNameMatchedAliases, (x) => x.score);
    results.push({
      type: "fuzzy-name",
      meta: fuzzyNameMatchedAliases.map((x) => x.value),
      alias: m.value,
      score: m.score,
      query
    });
  }
  if (smartIncludes((_a = item.file.parent) == null ? void 0 : _a.path, query, isNormalizeAccentsDiacritics)) {
    results.push({ type: "directory", meta: [item.file.path], query });
  }
  if (searchByHeaders) {
    const headers = item.headers.filter(
      (header) => smartIncludes(header, query, isNormalizeAccentsDiacritics)
    );
    if (headers.length > 0) {
      results.push({
        type: "header",
        meta: headers,
        query
      });
    }
  }
  if (searchByLinks) {
    const links = item.links.filter(
      (link) => smartIncludes(link, query, isNormalizeAccentsDiacritics)
    );
    if (links.length > 0) {
      results.push({
        type: "link",
        meta: links,
        query
      });
    }
  }
  if (searchByTags) {
    const tags = item.tags.filter(
      (tag) => smartIncludes(tag.slice(1), query, isNormalizeAccentsDiacritics)
    );
    if (tags.length > 0) {
      results.push({
        type: "tag",
        meta: tags,
        query
      });
    }
  }
  if (keysOfPropertyToSearch.length > 0) {
    const values = keysOfPropertyToSearch.map((x) => {
      var _a2, _b;
      return (_b = (_a2 = item.frontMatter) == null ? void 0 : _a2[x]) == null ? void 0 : _b.toString();
    }).filter((x) => x && smartIncludes(x, query, isNormalizeAccentsDiacritics)).filter(isPresent);
    if (values.length > 0) {
      results.push({
        type: "property",
        meta: values,
        query
      });
    }
  }
  return results.length === 0 ? [{ type: "not found", query }] : results;
}
function matchQueryAll(item, queries, options) {
  return queries.flatMap((q) => {
    var _a;
    const [query, negative] = q.startsWith("-") ? [q.slice(1), true] : [q, false];
    const matched = matchQuery(item, query, options);
    if (((_a = matched[0]) == null ? void 0 : _a.type) === "not found") {
      return negative ? [] : matched;
    }
    return negative ? [{ type: "not found", query }] : matched;
  });
}
function stampMatchResults(item, queries, options) {
  return {
    ...item,
    matchResults: matchQueryAll(item, queries, options)
  };
}
function getMatchedTitleAndAliases(item) {
  const matchTitle = item.matchResults.find(
    (x) => ["word-perfect", "prefix-name", "name", "fuzzy-name"].includes(x.type) && !x.alias
  );
  const displayedAliases = uniqFlatMap(
    item.matchResults.filter((res) => res.alias),
    (x) => {
      var _a;
      return (_a = x.meta) != null ? _a : [];
    }
  );
  return {
    title: matchTitle ? item.file.basename : void 0,
    aliases: displayedAliases
  };
}

// src/settings.ts
var import_obsidian3 = require("obsidian");

// src/sorters.ts
var sortPriorityList = [
  "Header match",
  "Last modified",
  "Last opened",
  "Created earliest",
  "Created latest",
  "Length",
  "Link match",
  "Name match",
  "Perfect word match",
  "Prefix name match",
  "Fuzzy name match",
  "Star",
  "Tag match",
  "Property match",
  "Alphabetical",
  "Alphabetical reverse"
];
function regardAsSortPriority(x) {
  return sortPriorityList.includes(x) || x.split(",").every((y) => y.startsWith("#")) || x.split(",").every((y) => y.startsWith("."));
}
function filterNoQueryPriorities(priorities) {
  return priorities.filter(
    (x) => [
      "Last opened",
      "Last modified",
      "Created earliest",
      "Created latest",
      "Star",
      "Alphabetical",
      "Alphabetical reverse"
    ].includes(x) || x.startsWith("#") || x.startsWith(".")
  );
}
function getComparator(priority) {
  switch (priority) {
    case "Header match":
      return priorityToHeader;
    case "Last modified":
      return priorityToLastModified;
    case "Last opened":
      return priorityToLastOpened;
    case "Created latest":
      return priorityToCreatedLatest;
    case "Created earliest":
      return priorityToCreatedEarliest;
    case "Length":
      return priorityToLength;
    case "Link match":
      return priorityToLink;
    case "Name match":
      return priorityToName;
    case "Perfect word match":
      return priorityToPerfectWord;
    case "Prefix name match":
      return priorityToPrefixName;
    case "Fuzzy name match":
      return priorityToFuzzyScore;
    case "Star":
      return priorityToStar;
    case "Tag match":
      return priorityToTag;
    case "Property match":
      return priorityToProperty;
    case "Alphabetical":
      return priorityToAlphabetical;
    case "Alphabetical reverse":
      return priorityToAlphabeticalReverse;
    default:
      if (priority.startsWith("#")) {
        const tags = priority.split(",");
        return (a, b) => priorityToTags(a, b, tags);
      }
      if (priority.startsWith(".")) {
        const extensions = priority.split(",").map((x) => x.slice(1));
        return (a, b) => priorityToExtensions(a, b, extensions);
      }
      throw new ExhaustiveError(priority);
  }
}
function sort(items, priorities, lastOpenFileIndexByPath) {
  const comparators = priorities.map(getComparator);
  return items.sort((a, b) => {
    let result;
    for (const comparator of comparators) {
      result = comparator(a, b, lastOpenFileIndexByPath);
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  });
}
function compare(a, b, toOrdered, order = "asc") {
  const oA = toOrdered(a);
  const oB = toOrdered(b);
  if (oA === oB) {
    return 0;
  }
  switch (order) {
    case "asc":
      if (oA > oB) {
        return 1;
      }
      if (oB > oA) {
        return -1;
      }
      return 0;
    case "desc":
      if (oA < oB) {
        return 1;
      }
      if (oB < oA) {
        return -1;
      }
      return 0;
  }
}
function priorityToPerfectWord(a, b) {
  return compare(
    a,
    b,
    (x) => x.matchResults.filter((x2) => x2.type === "word-perfect").map((x2) => x2.query).unique().length,
    "desc"
  );
}
function priorityToPrefixName(a, b) {
  return compare(
    a,
    b,
    (x) => x.matchResults.filter((x2) => x2.type === "prefix-name").map((x2) => x2.query).unique().length,
    "desc"
  );
}
function priorityToName(a, b) {
  return compare(
    a,
    b,
    (x) => x.matchResults.filter((x2) => x2.type === "name").map((x2) => x2.query).unique().length,
    "desc"
  );
}
function priorityToFuzzyScore(a, b) {
  return compare(
    a,
    b,
    (x) => Math.max(...x.matchResults.map((x2) => {
      var _a;
      return (_a = x2.score) != null ? _a : 0;
    })),
    "desc"
  );
}
function priorityToTag(a, b) {
  return compare(
    a,
    b,
    (x) => x.matchResults.filter((x2) => x2.type === "tag").map((x2) => x2.query).unique().length,
    "desc"
  );
}
function priorityToProperty(a, b) {
  return compare(
    a,
    b,
    (x) => x.matchResults.filter((x2) => x2.type === "property").map((x2) => x2.query).unique().length,
    "desc"
  );
}
function priorityToHeader(a, b) {
  return compare(
    a,
    b,
    (x) => x.matchResults.filter((x2) => x2.type === "header").map((x2) => x2.query).unique().length,
    "desc"
  );
}
function priorityToLink(a, b) {
  return compare(
    a,
    b,
    (x) => x.matchResults.filter((x2) => x2.type === "link").map((x2) => x2.query).unique().length,
    "desc"
  );
}
function priorityToLength(a, b) {
  return compare(
    a,
    b,
    (x) => x.matchResults[0].alias ? x.matchResults[0].alias.length : x.file.basename.length,
    "asc"
  );
}
function priorityToLastOpened(a, b, lastOpenFileIndexByPath) {
  return compare(
    a,
    b,
    (x) => {
      var _a;
      return (_a = lastOpenFileIndexByPath[x.file.path]) != null ? _a : 999999;
    },
    "asc"
  );
}
function priorityToLastModified(a, b) {
  return compare(a, b, (x) => x.file.stat.mtime, "desc");
}
function priorityToCreatedLatest(a, b) {
  return compare(a, b, (x) => x.file.stat.ctime, "desc");
}
function priorityToCreatedEarliest(a, b) {
  return compare(
    a,
    b,
    (x) => x.file.stat.ctime || Number.MAX_SAFE_INTEGER,
    "asc"
  );
}
function priorityToStar(a, b) {
  return compare(a, b, (x) => Number(x.starred), "desc");
}
var toComparedAlphabetical = (item) => {
  var _a, _b;
  return excludeEmoji((_b = (_a = item.matchResults[0]) == null ? void 0 : _a.alias) != null ? _b : item.file.basename).toLowerCase();
};
function priorityToAlphabetical(a, b) {
  return toComparedAlphabetical(a).localeCompare(toComparedAlphabetical(b));
}
function priorityToAlphabeticalReverse(a, b) {
  return toComparedAlphabetical(b).localeCompare(toComparedAlphabetical(a));
}
function priorityToTags(a, b, tags) {
  return compare(a, b, (x) => intersection([tags, x.tags]).length, "desc");
}
function priorityToExtensions(a, b, extensions) {
  return compare(
    a,
    b,
    (x) => Number(extensions.contains(x.file.extension)),
    "desc"
  );
}

// src/settings.ts
var searchTargetList = [
  "file",
  "opened file",
  "backlink",
  "link",
  "2-hop-link"
];
var createDefaultHotkeys = () => ({
  main: {
    up: [{ modifiers: ["Mod"], key: "p" }],
    down: [{ modifiers: ["Mod"], key: "n" }],
    "clear input": [{ modifiers: ["Mod"], key: "d" }],
    "replace input": [{ modifiers: [], key: "Tab" }],
    open: [{ modifiers: [], key: "Enter" }],
    "open in new tab": [{ modifiers: ["Mod"], key: "Enter" }],
    "open in new pane (horizontal)": [{ modifiers: ["Mod"], key: "-" }],
    "open in new pane (vertical)": [{ modifiers: ["Mod"], key: "i" }],
    "open in new window": [{ modifiers: ["Mod"], key: "o" }],
    "open in popup": [],
    "open in new tab in background": [{ modifiers: ["Alt"], key: "o" }],
    "open all in new tabs": [{ modifiers: ["Mod", "Shift", "Alt"], key: "o" }],
    preview: [{ modifiers: ["Mod"], key: "," }],
    create: [{ modifiers: ["Shift"], key: "Enter" }],
    "create in new tab": [{ modifiers: ["Mod", "Shift"], key: "Enter" }],
    "create in new window": [{ modifiers: ["Mod", "Shift"], key: "o" }],
    "create in new popup": [],
    "open in default app": [],
    "show in system explorer": [],
    "open in google": [{ modifiers: ["Mod"], key: "g" }],
    "open first URL": [{ modifiers: ["Mod"], key: "]" }],
    "insert to editor": [{ modifiers: ["Alt"], key: "Enter" }],
    "insert to editor in background": [],
    "insert all to editor": [{ modifiers: ["Alt", "Shift"], key: "Enter" }],
    "show backlinks": [{ modifiers: ["Mod"], key: "h" }],
    "show links": [{ modifiers: ["Mod"], key: "l" }],
    "show all results": [{ modifiers: ["Shift", "Alt"], key: "a" }],
    "navigate forward": [{ modifiers: ["Alt"], key: "ArrowRight" }],
    "navigate back": [{ modifiers: ["Alt"], key: "ArrowLeft" }],
    "close if opened": [],
    dismiss: [{ modifiers: [], key: "Escape" }]
  },
  folder: {
    up: [{ modifiers: ["Mod"], key: "p" }],
    down: [{ modifiers: ["Mod"], key: "n" }],
    "open in default app": [],
    dismiss: [{ modifiers: [], key: "Escape" }]
  },
  move: {
    up: [{ modifiers: ["Mod"], key: "p" }],
    down: [{ modifiers: ["Mod"], key: "n" }],
    "open in default app": [],
    dismiss: [{ modifiers: [], key: "Escape" }]
  },
  header: {
    up: [{ modifiers: ["Mod"], key: "p" }],
    down: [{ modifiers: ["Mod"], key: "n" }],
    "clear input": [{ modifiers: ["Mod"], key: "d" }],
    "move to next hit": [{ modifiers: [], key: "Tab" }],
    "move to previous hit": [{ modifiers: ["Shift"], key: "Tab" }],
    "toggle auto preview": [{ modifiers: ["Mod"], key: "," }],
    "insert all to editor": [{ modifiers: ["Alt", "Shift"], key: "Enter" }],
    dismiss: [{ modifiers: [], key: "Escape" }]
  },
  backlink: {
    up: [{ modifiers: ["Mod"], key: "p" }],
    down: [{ modifiers: ["Mod"], key: "n" }],
    open: [{ modifiers: [], key: "Enter" }],
    "open in new tab": [{ modifiers: ["Mod"], key: "Enter" }],
    "open in new pane (horizontal)": [{ modifiers: ["Mod"], key: "-" }],
    "open in new pane (vertical)": [{ modifiers: ["Mod"], key: "i" }],
    "open in new window": [{ modifiers: ["Mod"], key: "o" }],
    "open in popup": [],
    "open in new tab in background": [{ modifiers: ["Alt"], key: "o" }],
    "open all in new tabs": [{ modifiers: ["Mod", "Shift", "Alt"], key: "o" }],
    "show all results": [{ modifiers: ["Shift", "Alt"], key: "a" }],
    preview: [{ modifiers: ["Mod"], key: "," }],
    dismiss: [{ modifiers: [], key: "Escape" }]
  },
  link: {
    up: [{ modifiers: ["Mod"], key: "p" }],
    down: [{ modifiers: ["Mod"], key: "n" }],
    open: [{ modifiers: [], key: "Enter" }],
    "open in new tab": [{ modifiers: ["Mod"], key: "Enter" }],
    "open in new pane (horizontal)": [{ modifiers: ["Mod"], key: "-" }],
    "open in new pane (vertical)": [{ modifiers: ["Mod"], key: "i" }],
    "open in new window": [{ modifiers: ["Mod"], key: "o" }],
    "open in popup": [],
    "open in new tab in background": [{ modifiers: ["Alt"], key: "o" }],
    "open all in new tabs": [{ modifiers: ["Mod", "Shift", "Alt"], key: "o" }],
    "show all results": [{ modifiers: ["Shift", "Alt"], key: "a" }],
    preview: [{ modifiers: ["Mod"], key: "," }],
    dismiss: [{ modifiers: [], key: "Escape" }]
  },
  "in-file": {
    up: [{ modifiers: ["Mod"], key: "p" }],
    down: [{ modifiers: ["Mod"], key: "n" }],
    "show all results": [{ modifiers: ["Shift", "Alt"], key: "a" }],
    "toggle auto preview": [{ modifiers: ["Mod"], key: "," }],
    dismiss: [{ modifiers: [], key: "Escape" }]
  },
  grep: {
    search: [{ modifiers: [], key: "Tab" }],
    up: [{ modifiers: ["Mod"], key: "p" }],
    down: [{ modifiers: ["Mod"], key: "n" }],
    "clear input": [{ modifiers: ["Mod"], key: "d" }],
    "clear path": [{ modifiers: ["Alt"], key: "d" }],
    "set ./ to path": [{ modifiers: ["Alt"], key: "c" }],
    open: [{ modifiers: [], key: "Enter" }],
    "open in new tab": [{ modifiers: ["Mod"], key: "Enter" }],
    "open in new pane (horizontal)": [{ modifiers: ["Mod"], key: "-" }],
    "open in new pane (vertical)": [{ modifiers: ["Mod"], key: "i" }],
    "open in new window": [{ modifiers: ["Mod"], key: "o" }],
    "open in popup": [],
    "open in new tab in background": [{ modifiers: ["Alt"], key: "o" }],
    "open all in new tabs": [{ modifiers: ["Mod", "Shift", "Alt"], key: "o" }],
    preview: [{ modifiers: ["Mod"], key: "," }],
    dismiss: [{ modifiers: [], key: "Escape" }]
  }
});
var createDefaultExcludeFrontMatterKeys = () => [
  "aliases",
  "alias",
  "tag",
  "tags",
  "cssclass",
  "publish"
];
var createDefaultSearchCommand = () => ({
  name: "",
  searchBy: {
    tag: false,
    link: false,
    header: false,
    property: false
  },
  keysOfPropertyToSearch: [],
  searchTarget: "file",
  allowFuzzySearchForSearchTarget: false,
  minFuzzyMatchScore: 0.5,
  targetExtensions: [],
  floating: false,
  showFrontMatter: false,
  excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
  defaultInput: "",
  restoreLastInput: false,
  commandPrefix: "",
  sortPriorities: [],
  includePrefixPathPatterns: [],
  excludePrefixPathPatterns: [],
  expand: true
});
var createDefaultLinkSearchCommand = () => ({
  name: "Link search",
  searchBy: {
    tag: false,
    link: false,
    header: false,
    property: false
  },
  keysOfPropertyToSearch: [],
  searchTarget: "link",
  allowFuzzySearchForSearchTarget: false,
  minFuzzyMatchScore: 0.5,
  targetExtensions: [],
  floating: false,
  showFrontMatter: false,
  excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
  defaultInput: "",
  restoreLastInput: false,
  commandPrefix: "",
  sortPriorities: [],
  includePrefixPathPatterns: [],
  excludePrefixPathPatterns: [],
  expand: false
});
var createDefaultBacklinkSearchCommand = () => ({
  name: "Backlink search",
  searchBy: {
    tag: false,
    link: false,
    header: false,
    property: false
  },
  keysOfPropertyToSearch: [],
  searchTarget: "backlink",
  allowFuzzySearchForSearchTarget: false,
  minFuzzyMatchScore: 0.5,
  targetExtensions: ["md"],
  floating: false,
  showFrontMatter: false,
  excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
  defaultInput: "",
  restoreLastInput: false,
  commandPrefix: "",
  sortPriorities: ["Last opened", "Last modified"],
  includePrefixPathPatterns: [],
  excludePrefixPathPatterns: [],
  expand: false
});
var createDefault2HopLinkSearchCommand = () => ({
  name: "2 hop link search",
  searchBy: {
    tag: true,
    link: false,
    header: false,
    property: false
  },
  keysOfPropertyToSearch: [],
  searchTarget: "2-hop-link",
  allowFuzzySearchForSearchTarget: false,
  minFuzzyMatchScore: 0.5,
  targetExtensions: [],
  floating: false,
  showFrontMatter: false,
  excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
  defaultInput: "",
  restoreLastInput: false,
  commandPrefix: "",
  sortPriorities: [
    "Prefix name match",
    "Alphabetical",
    ".md",
    "Last opened",
    "Last modified"
  ],
  includePrefixPathPatterns: [],
  excludePrefixPathPatterns: [],
  expand: false
});
var createPreSettingSearchCommands = () => [
  {
    name: "Recent search",
    searchBy: {
      tag: true,
      header: false,
      link: false,
      property: false
    },
    keysOfPropertyToSearch: [],
    searchTarget: "file",
    allowFuzzySearchForSearchTarget: false,
    minFuzzyMatchScore: 0.5,
    targetExtensions: [],
    floating: false,
    showFrontMatter: false,
    excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
    defaultInput: "",
    restoreLastInput: false,
    commandPrefix: ":e ",
    sortPriorities: ["Name match", ".md", "Last opened", "Last modified"],
    includePrefixPathPatterns: [],
    excludePrefixPathPatterns: [],
    expand: true
  },
  {
    name: "File name search",
    searchBy: {
      tag: false,
      link: false,
      header: false,
      property: false
    },
    keysOfPropertyToSearch: [],
    searchTarget: "file",
    allowFuzzySearchForSearchTarget: false,
    minFuzzyMatchScore: 0.5,
    targetExtensions: [],
    floating: false,
    showFrontMatter: false,
    excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
    defaultInput: "",
    restoreLastInput: false,
    commandPrefix: ":f ",
    sortPriorities: [
      "Prefix name match",
      "Alphabetical",
      ".md",
      "Last opened",
      "Last modified"
    ],
    includePrefixPathPatterns: [],
    excludePrefixPathPatterns: [],
    expand: false
  },
  {
    name: "File name fuzzy search",
    searchBy: {
      tag: false,
      link: false,
      header: false,
      property: false
    },
    keysOfPropertyToSearch: [],
    searchTarget: "file",
    allowFuzzySearchForSearchTarget: true,
    minFuzzyMatchScore: 0.5,
    targetExtensions: [],
    floating: false,
    showFrontMatter: false,
    excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
    defaultInput: "",
    restoreLastInput: false,
    commandPrefix: "",
    sortPriorities: [
      "Prefix name match",
      "Fuzzy name match",
      ".md",
      "Last opened",
      "Last modified"
    ],
    includePrefixPathPatterns: [],
    excludePrefixPathPatterns: [],
    expand: false
  },
  {
    name: "Landmark search",
    searchBy: {
      tag: true,
      link: true,
      header: true,
      property: false
    },
    keysOfPropertyToSearch: [],
    searchTarget: "file",
    allowFuzzySearchForSearchTarget: false,
    minFuzzyMatchScore: 0.5,
    targetExtensions: [],
    floating: false,
    showFrontMatter: false,
    excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
    defaultInput: "",
    restoreLastInput: false,
    commandPrefix: ":l ",
    sortPriorities: [
      "Prefix name match",
      "Name match",
      "Tag match",
      "Header match",
      "Link match",
      ".md",
      "Last opened",
      "Last modified"
    ],
    includePrefixPathPatterns: [],
    excludePrefixPathPatterns: [],
    expand: false
  },
  {
    name: "Star search",
    searchBy: {
      tag: false,
      link: false,
      header: false,
      property: false
    },
    keysOfPropertyToSearch: [],
    searchTarget: "file",
    allowFuzzySearchForSearchTarget: false,
    minFuzzyMatchScore: 0.5,
    targetExtensions: [],
    floating: false,
    showFrontMatter: false,
    excludeFrontMatterKeys: createDefaultExcludeFrontMatterKeys(),
    defaultInput: "",
    restoreLastInput: false,
    commandPrefix: ":s ",
    sortPriorities: ["Star", ".md", "Last opened", "Last modified"],
    includePrefixPathPatterns: [],
    excludePrefixPathPatterns: [],
    expand: false
  },
  createDefaultLinkSearchCommand(),
  createDefault2HopLinkSearchCommand()
];
var DEFAULT_SETTINGS = {
  searchDelayMilliSeconds: 0,
  maxNumberOfSuggestions: 50,
  normalizeAccentsAndDiacritics: false,
  useSelectionWordsAsDefaultInputQuery: false,
  preventDuplicateTabs: false,
  // Appearance
  showDirectory: true,
  showDirectoryAtNewLine: false,
  showFullPathOfDirectory: false,
  showAliasesOnTop: false,
  displayAliaseAsTitle: false,
  showExistingFilesOnly: false,
  hideGutterIcons: false,
  hideHotkeyGuides: false,
  // Hot keys in dialog
  userAltInsteadOfModForQuickResultSelection: false,
  hotkeys: createDefaultHotkeys(),
  // Searches
  searchCommands: createPreSettingSearchCommands(),
  searchesAutoAliasTransform: {
    enabled: false,
    aliasPattern: "",
    aliasFormat: ""
  },
  // Header search
  autoPreviewInFloatingHeaderSearch: true,
  // Backlink search
  backlinkExcludePrefixPathPatterns: [],
  // In file search
  inFileContextLines: 2,
  autoPreviewInFloatingInFileSearch: false,
  inFileMaxDisplayLengthAroundMatchedWord: 64,
  // Grep
  ripgrepCommand: "rg",
  grepExtensions: ["md"],
  maxDisplayLengthAroundMatchedWord: 64,
  // Move file to another folder
  moveFileExcludePrefixPathPatterns: [],
  // debug
  showLogAboutPerformanceInConsole: false,
  showFuzzyMatchScore: false
};
var AnotherQuickSwitcherSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.resetLock = true;
    this.hotkeyExpandedStatus = {
      main: false,
      folder: false,
      move: false,
      header: false,
      backlink: false,
      link: false,
      "in-file": false,
      grep: false
    };
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Another Quick Switcher - Settings" });
    this.addGeneralSettings(containerEl);
    this.addAppearanceSettings(containerEl);
    this.addHotKeysInDialogSettings(containerEl);
    this.addSearchSettings(containerEl);
    this.addHeaderSearchSettings(containerEl);
    this.addBacklinkSettings(containerEl);
    this.addInFileSettings(containerEl);
    this.addGrepSettings(containerEl);
    this.addMoveSettings(containerEl);
    this.addDebugSettings(containerEl);
  }
  addGeneralSettings(containerEl) {
    new import_obsidian3.Setting(containerEl).setName("Search delay milli-seconds").setDesc("If keyboard operation is slow, try increasing the value").addSlider(
      (sc) => sc.setLimits(0, 1e3, 10).setValue(this.plugin.settings.searchDelayMilliSeconds).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.searchDelayMilliSeconds = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Max number of suggestions").addSlider(
      (sc) => sc.setLimits(1, 255, 1).setValue(this.plugin.settings.maxNumberOfSuggestions).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxNumberOfSuggestions = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Normalize accents/diacritics").addToggle((tc) => {
      tc.setValue(
        this.plugin.settings.normalizeAccentsAndDiacritics
      ).onChange(async (value) => {
        this.plugin.settings.normalizeAccentsAndDiacritics = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.normalizeAccentsAndDiacritics) {
      containerEl.createEl("div", {
        text: "! If enabled, it is about 2 to 5 times slower than disabled",
        cls: "another-quick-switcher__settings__warning"
      });
    }
    new import_obsidian3.Setting(containerEl).setName("Use selection words as a default input query").addToggle((tc) => {
      tc.setValue(
        this.plugin.settings.useSelectionWordsAsDefaultInputQuery
      ).onChange(async (value) => {
        this.plugin.settings.useSelectionWordsAsDefaultInputQuery = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Prevent duplicate tabs").setDesc(
      "If a file is already opened as a tab, it will not open in a new tab; instead, the existing tab will be activated. This option is enabled for three commands: 'open in new tab', 'open in new tab in background', and 'open all in new tabs'."
    ).addToggle((tc) => {
      tc.setValue(this.plugin.settings.preventDuplicateTabs).onChange(
        async (value) => {
          this.plugin.settings.preventDuplicateTabs = value;
          await this.plugin.saveSettings();
        }
      );
    });
  }
  addAppearanceSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F441}Appearance" });
    new import_obsidian3.Setting(containerEl).setName("Show directory").addToggle((tc) => {
      tc.setValue(this.plugin.settings.showDirectory).onChange(
        async (value) => {
          this.plugin.settings.showDirectory = value;
          await this.plugin.saveSettings();
          this.display();
        }
      );
    });
    if (this.plugin.settings.showDirectory) {
      new import_obsidian3.Setting(containerEl).setName("Show directory at the new line").setClass("another-quick-switcher__settings__nested").addToggle((tc) => {
        tc.setValue(this.plugin.settings.showDirectoryAtNewLine).onChange(
          async (value) => {
            this.plugin.settings.showDirectoryAtNewLine = value;
            await this.plugin.saveSettings();
          }
        );
      });
      new import_obsidian3.Setting(containerEl).setName("Show full path of directory").setClass("another-quick-switcher__settings__nested").addToggle((tc) => {
        tc.setValue(this.plugin.settings.showFullPathOfDirectory).onChange(
          async (value) => {
            this.plugin.settings.showFullPathOfDirectory = value;
            await this.plugin.saveSettings();
          }
        );
      });
    }
    new import_obsidian3.Setting(containerEl).setName("Display alias as title on keyword match").setDesc(
      "When a keyword matches an alias, display the alias as the title."
    ).addToggle((tc) => {
      tc.setValue(this.plugin.settings.showAliasesOnTop).onChange(
        async (value) => {
          this.plugin.settings.showAliasesOnTop = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian3.Setting(containerEl).setName("Display the alias as the title.").addToggle((tc) => {
      tc.setValue(this.plugin.settings.displayAliaseAsTitle).onChange(
        async (value) => {
          this.plugin.settings.displayAliaseAsTitle = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian3.Setting(containerEl).setName("Show existing files only").addToggle((tc) => {
      tc.setValue(this.plugin.settings.showExistingFilesOnly).onChange(
        async (value) => {
          this.plugin.settings.showExistingFilesOnly = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian3.Setting(containerEl).setName("Hide gutter icons").addToggle((tc) => {
      tc.setValue(this.plugin.settings.hideGutterIcons).onChange(
        async (value) => {
          this.plugin.settings.hideGutterIcons = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian3.Setting(containerEl).setName("Hide hotkey guides").addToggle((tc) => {
      tc.setValue(this.plugin.settings.hideHotkeyGuides).onChange(
        async (value) => {
          this.plugin.settings.hideHotkeyGuides = value;
          await this.plugin.saveSettings();
        }
      );
    });
  }
  addHotKeysInDialogSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u2328Hot keys in dialog" });
    new import_obsidian3.Setting(containerEl).setName(
      "Use `alt 1\uFF5E9` instead of `ctrl/cmd 1\uFF5E9` for quick result selection"
    ).addToggle((tc) => {
      tc.setValue(
        this.plugin.settings.userAltInsteadOfModForQuickResultSelection
      ).onChange(async (value) => {
        this.plugin.settings.userAltInsteadOfModForQuickResultSelection = value;
        await this.plugin.saveSettings();
      });
    });
    const addHotkeyItems = (dialogKey, div) => {
      if (!this.hotkeyExpandedStatus[dialogKey]) {
        return;
      }
      const addHotKeyItem = (name, command) => {
        new import_obsidian3.Setting(div).setName(name).setClass("another-quick-switcher__settings__dialog-hotkey-item").addText((cb) => {
          const dialog = this.plugin.settings.hotkeys[dialogKey];
          return cb.setValue(hotkey2String(dialog[command][0])).onChange(async (value) => {
            var _a, _b;
            const hk = string2Hotkey(
              value,
              (_b = (_a = dialog[command][0]) == null ? void 0 : _a.hideHotkeyGuide) != null ? _b : false
            );
            dialog[command] = hk ? [hk] : [];
            await this.plugin.saveSettings();
          });
        }).addToggle((cb) => {
          var _a;
          const dialog = this.plugin.settings.hotkeys[dialogKey];
          return cb.setTooltip("Show hotkey guide if enabled").setValue(!((_a = dialog[command][0]) == null ? void 0 : _a.hideHotkeyGuide)).onChange(async (showHotkeyGuide) => {
            dialog[command] = dialog[command][0] ? [
              {
                ...dialog[command][0],
                hideHotkeyGuide: !showHotkeyGuide
              }
            ] : [];
            await this.plugin.saveSettings();
          });
        });
      };
      const keys = Object.keys(this.plugin.settings.hotkeys[dialogKey]);
      for (const k of keys) {
        addHotKeyItem(k, k);
      }
    };
    const addHotkeysForDialog = (dialogKey, dialogName) => {
      const div = createDiv({
        cls: "another-quick-switcher__settings__dialog-hotkey"
      });
      containerEl.append(div);
      const li = createEl("li");
      li.append(
        "You can know the keycode at ",
        createEl("a", {
          text: "keycode.info",
          href: "https://keycode.info/"
        }),
        ". (Press any key and show 'event.key')"
      );
      li.createEl("ul").createEl("li", {
        text: "For the space key, please set the value to 'Space'."
      });
      const ul = createEl("ul");
      ul.createEl("li", {
        text: "'Ctrl a' means pressing the Ctrl key and the A key."
      });
      ul.createEl("li", {
        text: "Use 'Mod' instead of 'Ctrl' on Windows or 'Cmd' on macOS."
      });
      ul.append(li);
      const df = document.createDocumentFragment();
      df.append(ul);
      new import_obsidian3.Setting(div).setHeading().setName(dialogName).setDesc(df).addExtraButton(
        (btn) => btn.setIcon(
          this.hotkeyExpandedStatus[dialogKey] ? "chevron-up" : "chevron-down"
        ).setTooltip(
          this.hotkeyExpandedStatus[dialogKey] ? "fold" : "unfold"
        ).onClick(() => {
          this.hotkeyExpandedStatus[dialogKey] = !this.hotkeyExpandedStatus[dialogKey];
          this.display();
        })
      );
      addHotkeyItems(dialogKey, div);
    };
    addHotkeysForDialog("main", "Main dialog");
    addHotkeysForDialog("folder", "Folder dialog");
    addHotkeysForDialog("header", "Header dialog");
    addHotkeysForDialog("backlink", "Backlink dialog");
    addHotkeysForDialog("link", "Link dialog");
    addHotkeysForDialog("in-file", "In File dialog");
    addHotkeysForDialog("grep", "Grep dialog");
  }
  addSearchSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F50D} Search commands" });
    this.plugin.settings.searchCommands.forEach((_, i) => {
      this.addSearchCommandSetting(
        containerEl,
        this.plugin.settings.searchCommands[i]
      );
    });
    new import_obsidian3.Setting(containerEl).setHeading().addButton((btn) => {
      btn.setButtonText("Add").setTooltip("Add a new command").setCta().setClass(
        "another-quick-switcher__settings__search-command__add-button"
      ).onClick(async (_) => {
        this.plugin.settings.searchCommands.push(
          createDefaultSearchCommand()
        );
        this.display();
      });
    }).addButton((btn) => {
      btn.setButtonText("Save").setTooltip(
        "You must click this button to save settings before closing Obsidian"
      ).setCta().setClass(
        "another-quick-switcher__settings__search-command__save-button"
      ).onClick(async (_) => {
        this.plugin.settings.searchCommands = this.plugin.settings.searchCommands.filter((x) => x.name);
        const invalidValues = this.plugin.settings.searchCommands.flatMap((x) => x.sortPriorities).filter((x) => !regardAsSortPriority(x));
        if (invalidValues.length > 0) {
          new import_obsidian3.Notice(
            `
Invalid sort priorities:
${invalidValues.map((x) => `- ${x}`).join("\n")}
`.trim(),
            0
          );
          return;
        }
        await this.plugin.saveSettings();
        this.display();
        this.plugin.reloadCommands();
        new import_obsidian3.Notice("Save and reload commands");
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Reset all search commands").setClass("another-quick-switcher__settings__danger").setDesc(
      "It means your customized commands will be removed. If you reset unintentionally, you can restore the search commands by closing settings and Obsidian immediately, then restart Obsidian."
    ).addToggle((cb) => {
      cb.setValue(this.resetLock).onChange((lock) => {
        this.resetLock = lock;
        this.display();
      });
      if (this.resetLock) {
        cb.setTooltip(
          "Turn off the lock, if you want to reset all search commands"
        );
      }
    }).addButton((btn) => {
      btn.setButtonText("Reset").setTooltip("Reset all search commands!!").setDisabled(this.resetLock).onClick(() => {
        this.plugin.settings.searchCommands = createPreSettingSearchCommands();
        this.display();
      });
      if (!this.resetLock) {
        btn.setCta();
      }
    });
    new import_obsidian3.Setting(containerEl).setName("Auto alias transform").setDesc(
      "Transforms a selected link candidate into an internal link with an aliase based on a regex-defined rule when using the insert to editor command."
    ).addToggle((tc) => {
      tc.setValue(
        this.plugin.settings.searchesAutoAliasTransform.enabled
      ).onChange(async (value) => {
        this.plugin.settings.searchesAutoAliasTransform.enabled = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.searchesAutoAliasTransform.enabled) {
      const ex1 = String.raw`Ex: (?<name>.+) \(.+\)$`;
      new import_obsidian3.Setting(containerEl).setName("Alias pattern").setDesc(
        `Specifies the regex pattern to identify parts of the link candidate for transformation into an alias. ${ex1}`
      ).setClass("another-quick-switcher__settings__nested").addText((cb) => {
        cb.setValue(
          this.plugin.settings.searchesAutoAliasTransform.aliasPattern
        ).onChange(async (value) => {
          this.plugin.settings.searchesAutoAliasTransform.aliasPattern = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian3.Setting(containerEl).setName("Alias format").setDesc(
        "Defines the format for the alias after transformation, using regex-captured groups from the candidate name. Ex: $<name>"
      ).setClass("another-quick-switcher__settings__nested").addText((cb) => {
        cb.setValue(
          this.plugin.settings.searchesAutoAliasTransform.aliasFormat
        ).onChange(async (value) => {
          this.plugin.settings.searchesAutoAliasTransform.aliasFormat = value;
          await this.plugin.saveSettings();
        });
      });
    }
  }
  addSearchCommandSetting(containerEl, command) {
    const div = createDiv({
      cls: "another-quick-switcher__settings__search-command"
    });
    containerEl.append(div);
    new import_obsidian3.Setting(div).setClass("another-quick-switcher__settings__search-command__header").setHeading().addText((tc) => {
      const el = tc.setPlaceholder("Command name").setValue(command.name).onChange(async (value) => {
        command.name = value;
      });
      el.inputEl.setAttribute("style", "text-align: left");
      return el;
    }).addExtraButton((btn) => {
      btn.setTooltip("Delete a command (!! it will never be restored !!)").setIcon("trash-2").onClick(() => {
        this.plugin.settings.searchCommands.remove(command);
        this.display();
      });
      btn.extraSettingsEl.addClass(
        "another-quick-switcher__settings__search-command__header__delete"
      );
      return btn;
    }).addExtraButton((btn) => {
      btn.setIcon(command.expand ? "chevron-up" : "chevron-down").setTooltip(command.expand ? "fold" : "unfold").onClick(() => {
        command.expand = !command.expand;
        this.display();
      });
      btn.extraSettingsEl.addClass(
        "another-quick-switcher__settings__search-command__header__fold-button"
      );
      return btn;
    });
    if (!command.expand) {
      return;
    }
    const buttonClass = "another-quick-switcher__settings__search-command__search-by-button";
    const buttonEnabledClass = "another-quick-switcher__settings__search-command__search-by-button_enabled";
    const buttonDisabledClass = "another-quick-switcher__settings__search-command__search-by-button_disabled";
    new import_obsidian3.Setting(div).setName("Search by").setDesc("Click the button to enable/disable the search target").addButton((bc) => {
      const coloring = () => {
        bc.buttonEl.removeClass(buttonEnabledClass, buttonDisabledClass);
        bc.buttonEl.addClass(
          command.searchBy.tag ? buttonEnabledClass : buttonDisabledClass
        );
      };
      bc.setButtonText("Tag").setClass(buttonClass).onClick(async () => {
        command.searchBy.tag = !command.searchBy.tag;
        coloring();
      });
      coloring();
      return bc;
    }).addButton((bc) => {
      const coloring = () => {
        bc.buttonEl.removeClass(buttonEnabledClass, buttonDisabledClass);
        bc.buttonEl.addClass(
          command.searchBy.header ? buttonEnabledClass : buttonDisabledClass
        );
      };
      bc.setButtonText("Header").setClass(buttonClass).onClick(async () => {
        command.searchBy.header = !command.searchBy.header;
        coloring();
      });
      coloring();
      return bc;
    }).addButton((bc) => {
      const coloring = () => {
        bc.buttonEl.removeClass(buttonEnabledClass, buttonDisabledClass);
        bc.buttonEl.addClass(
          command.searchBy.link ? buttonEnabledClass : buttonDisabledClass
        );
      };
      bc.setButtonText("Link").setClass(buttonClass).onClick(async () => {
        command.searchBy.link = !command.searchBy.link;
        coloring();
      });
      coloring();
      return bc;
    }).addButton((bc) => {
      const coloring = () => {
        bc.buttonEl.removeClass(buttonEnabledClass, buttonDisabledClass);
        bc.buttonEl.addClass(
          command.searchBy.property ? buttonEnabledClass : buttonDisabledClass
        );
      };
      bc.setButtonText("Property").setClass(buttonClass).onClick(async () => {
        command.searchBy.property = !command.searchBy.property;
        coloring();
        this.display();
      });
      coloring();
      return bc;
    });
    if (command.searchBy.property) {
      new import_obsidian3.Setting(div).setName("Keys of the property to search").setDesc("Multiple entries can be specified, separated by line breaks.").addTextArea((tc) => {
        const el = tc.setValue(command.keysOfPropertyToSearch.join("\n")).onChange(async (value) => {
          command.keysOfPropertyToSearch = smartLineBreakSplit(value);
        });
        el.inputEl.className = "another-quick-switcher__settings__keys_of_property_to_search";
        return el;
      });
    }
    new import_obsidian3.Setting(div).setName("Search target").addDropdown((dc) => {
      dc.addOptions(mirror([...searchTargetList])).setValue(command.searchTarget).onChange(async (value) => {
        command.searchTarget = value;
      });
    });
    new import_obsidian3.Setting(div).setName('Allow fuzzy search for "Search target"').addToggle((cb) => {
      cb.setValue(command.allowFuzzySearchForSearchTarget).onChange(
        async (value) => {
          command.allowFuzzySearchForSearchTarget = value;
        }
      );
    });
    new import_obsidian3.Setting(div).setName("Min fuzzy match score").setDesc(
      "Only show suggestion those score is more than the specific score"
    ).addSlider(
      (sc) => sc.setLimits(0, 10, 0.1).setValue(command.minFuzzyMatchScore).setDynamicTooltip().onChange(async (value) => {
        command.minFuzzyMatchScore = value;
      })
    );
    new import_obsidian3.Setting(div).setName("Target extensions").setDesc(
      "If set, only files whose extension equals will be suggested. If empty, all files will be suggested. It can set multi extensions using comma."
    ).addTextArea(
      (tc) => tc.setPlaceholder("(ex: md,png,canvas)").setValue(command.targetExtensions.join(",")).onChange(async (value) => {
        command.targetExtensions = smartCommaSplit(value);
      })
    );
    new import_obsidian3.Setting(div).setName("Floating").addToggle((cb) => {
      cb.setValue(command.floating).onChange(async (value) => {
        command.floating = value;
        this.display();
      });
    });
    new import_obsidian3.Setting(div).setName("Show front matter").addToggle((cb) => {
      cb.setValue(command.showFrontMatter).onChange(async (value) => {
        command.showFrontMatter = value;
        this.display();
      });
    });
    if (command.showFrontMatter) {
      new import_obsidian3.Setting(div).setName("Exclude front matter keys").setDesc("It can set multi patterns by line breaks.").addTextArea((tc) => {
        const el = tc.setValue(command.excludeFrontMatterKeys.join("\n")).onChange(async (value) => {
          command.excludeFrontMatterKeys = smartLineBreakSplit(value);
        });
        el.inputEl.className = "another-quick-switcher__settings__exclude_front_matter_keys";
        return el;
      });
    }
    new import_obsidian3.Setting(div).setName("Default input").setDesc("Default input strings when it opens the dialog").addText(
      (tc) => tc.setValue(command.defaultInput).setPlaceholder("(ex: #todo )").onChange(async (value) => {
        command.defaultInput = value;
      })
    );
    new import_obsidian3.Setting(div).setName("Restore last input").setDesc(
      "If enabled, this option will restore the last input, shared across all searches where it is enabled."
    ).addToggle((tc) => {
      tc.setValue(command.restoreLastInput).onChange(async (value) => {
        command.restoreLastInput = value;
      });
    });
    new import_obsidian3.Setting(div).setName("Command prefix").setDesc(
      "For example, if it sets ':r ', a query starts with ':r ' means that search as this command"
    ).addText(
      (tc) => tc.setValue(command.commandPrefix).setPlaceholder("(ex: :r )").onChange(async (value) => {
        command.commandPrefix = value;
      })
    );
    const df = document.createDocumentFragment();
    df.append(
      "Valid sort priorities refer to ",
      createEl("a", {
        text: "README",
        href: "https://github.com/tadashi-aikawa/obsidian-another-quick-switcher#sort-priorities"
      })
    );
    new import_obsidian3.Setting(div).setName("Sort priorities").setDesc(df).addTextArea((tc) => {
      const el = tc.setPlaceholder("").setValue(command.sortPriorities.join("\n")).onChange(async (value) => {
        const priorities = smartLineBreakSplit(value);
        command.sortPriorities = priorities;
      });
      el.inputEl.addClass(
        "another-quick-switcher__settings__search-command__sort-priority"
      );
      return el;
    });
    new import_obsidian3.Setting(div).setName("Include prefix path patterns").setDesc(
      "If set, only files whose paths start with one of the patterns will be suggested. It can set multi patterns by line breaks. <current_dir> means current directory."
    ).addTextArea((tc) => {
      const el = tc.setPlaceholder("(ex: Notes/Private)").setValue(command.includePrefixPathPatterns.join("\n")).onChange(async (value) => {
        command.includePrefixPathPatterns = smartLineBreakSplit(value);
      });
      el.inputEl.className = "another-quick-switcher__settings__include_path_patterns";
      return el;
    });
    new import_obsidian3.Setting(div).setName("Exclude prefix path patterns").setDesc(
      "If set, files whose paths start with one of the patterns will not be suggested. It can set multi patterns by line breaks. <current_dir> means current directory."
    ).addTextArea((tc) => {
      const el = tc.setPlaceholder("(ex: Notes/Private)").setValue(command.excludePrefixPathPatterns.join("\n")).onChange(async (value) => {
        command.excludePrefixPathPatterns = smartLineBreakSplit(value);
      });
      el.inputEl.className = "another-quick-switcher__settings__exclude_path_patterns";
      return el;
    });
  }
  addHeaderSearchSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F4D2} Header search" });
    new import_obsidian3.Setting(containerEl).setName("Auto preview in the floating mode").addToggle((tc) => {
      tc.setValue(
        this.plugin.settings.autoPreviewInFloatingHeaderSearch
      ).onChange(async (value) => {
        this.plugin.settings.autoPreviewInFloatingHeaderSearch = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addBacklinkSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F50D} Backlink search" });
    new import_obsidian3.Setting(containerEl).setName('Exclude prefix path patterns for "Backlink search"').setDesc(
      "If set, folders whose paths start with one of the patterns will not be suggested. It can set multi patterns by line breaks"
    ).addTextArea((tc) => {
      const el = tc.setPlaceholder("Prefix match patterns").setValue(
        this.plugin.settings.backlinkExcludePrefixPathPatterns.join("\n")
      ).onChange(async (value) => {
        this.plugin.settings.backlinkExcludePrefixPathPatterns = smartLineBreakSplit(value);
        await this.plugin.saveSettings();
      });
      el.inputEl.className = "another-quick-switcher__settings__ignore_path_patterns";
      return el;
    });
  }
  addInFileSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F50D} In file search" });
    new import_obsidian3.Setting(containerEl).setName("Context Lines").setDesc(
      "Specifies the number of lines to display before and after the target line. For instance, setting this to '2' would display two lines before and two lines after the target line, providing context to the selected text"
    ).addSlider(
      (sc) => sc.setLimits(0, 10, 1).setValue(this.plugin.settings.inFileContextLines).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.inFileContextLines = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Auto preview in the floating mode").addToggle((tc) => {
      tc.setValue(
        this.plugin.settings.autoPreviewInFloatingInFileSearch
      ).onChange(async (value) => {
        this.plugin.settings.autoPreviewInFloatingInFileSearch = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Max display length around matched word").setDesc(
      "Maximum display character count before or after the matched word."
    ).addSlider(
      (sc) => sc.setLimits(1, 255, 1).setValue(
        this.plugin.settings.inFileMaxDisplayLengthAroundMatchedWord
      ).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.inFileMaxDisplayLengthAroundMatchedWord = value;
        await this.plugin.saveSettings();
      })
    );
  }
  addGrepSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F50D} Grep" });
    new import_obsidian3.Setting(containerEl).setName("Ripgrep command").setDesc("A command that can execute ripgrep").addText(
      (tc) => tc.setValue(this.plugin.settings.ripgrepCommand).onChange(async (value) => {
        this.plugin.settings.ripgrepCommand = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Extensions").addText(
      (tc) => tc.setPlaceholder("(ex: md,html,css)").setValue(this.plugin.settings.grepExtensions.join(",")).onChange(async (value) => {
        this.plugin.settings.grepExtensions = smartCommaSplit(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Max display length around matched word").setDesc(
      "Maximum display character count before or after the matched word."
    ).addSlider(
      (sc) => sc.setLimits(1, 255, 1).setValue(this.plugin.settings.maxDisplayLengthAroundMatchedWord).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxDisplayLengthAroundMatchedWord = value;
        await this.plugin.saveSettings();
      })
    );
  }
  addMoveSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F4C1} Move file to another folder" });
    new import_obsidian3.Setting(containerEl).setName('Exclude prefix path patterns for "Move file to another folder"').setDesc(
      "If set, folders whose paths start with one of the patterns will not be suggested. It can set multi patterns by line breaks"
    ).addTextArea((tc) => {
      const el = tc.setPlaceholder("Prefix match patterns").setValue(
        this.plugin.settings.moveFileExcludePrefixPathPatterns.join("\n")
      ).onChange(async (value) => {
        this.plugin.settings.moveFileExcludePrefixPathPatterns = smartLineBreakSplit(value);
        await this.plugin.saveSettings();
      });
      el.inputEl.className = "another-quick-switcher__settings__ignore_path_patterns";
      return el;
    });
  }
  addDebugSettings(containerEl) {
    containerEl.createEl("h3", { text: "Debug" });
    new import_obsidian3.Setting(containerEl).setName("Show log about performance in a console").addToggle((tc) => {
      tc.setValue(
        this.plugin.settings.showLogAboutPerformanceInConsole
      ).onChange(async (value) => {
        this.plugin.settings.showLogAboutPerformanceInConsole = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Show fuzzy match score in the dialog").addToggle((tc) => {
      tc.setValue(this.plugin.settings.showFuzzyMatchScore).onChange(
        async (value) => {
          this.plugin.settings.showFuzzyMatchScore = value;
          await this.plugin.saveSettings();
        }
      );
    });
  }
};

// src/utils/logger.ts
function buildLogMessage(message, msec) {
  return `${message}: ${Math.round(msec)}[ms]`;
}
var Logger = class _Logger {
  constructor(settings) {
    this.settings = settings;
  }
  static of(settings) {
    return new _Logger(settings);
  }
  showDebugLog(message, startTs) {
    if (this.settings.showLogAboutPerformanceInConsole) {
      console.log(buildLogMessage(message, performance.now() - startTs));
    }
  }
};

// src/ui/icons.ts
var FOLDER = `<svg viewBox="0 0 100 100" class="folder" width="17" height="17"><path fill="currentColor" stroke="currentColor" d="M6.1,8c-3.3,0-6,2.7-6,6v73.8c-0.1,0.5-0.1,0.9,0.1,1.4c0.6,2.7,3,4.8,5.9,4.8h78c3,0,5.4-2.2,5.9-5.1 c0-0.1,0.1-0.2,0.1-0.4c0,0,0-0.1,0-0.1l0.1-0.3c0,0,0,0,0-0.1l9.9-53.6l0.1-0.2V34c0-3.3-2.7-6-6-6v-6c0-3.3-2.7-6-6-6H36.1 c0,0,0,0-0.1,0c-0.1,0-0.2-0.2-0.6-0.6c-0.5-0.6-1.1-1.5-1.7-2.5c-0.6-1-1.3-2.1-2.1-3C30.9,9,29.7,8,28.1,8L6.1,8z M6.1,12h22 c-0.1,0,0.1,0,0.6,0.6c0.5,0.6,1.1,1.5,1.7,2.5c0.6,1,1.3,2.1,2.1,3c0.8,0.9,1.9,1.9,3.6,1.9h52c1.1,0,2,0.9,2,2v6h-74 c-3.1,0-5.7,2.5-5.9,5.6h-0.1L10.1,34l-6,32.4V14C4.1,12.9,4.9,12,6.1,12z M16.1,32h78c1.1,0,2,0.9,2,2l-9.8,53.1l-0.1,0.1 c0,0.1,0,0.2-0.1,0.2c0,0.1,0,0.2-0.1,0.2c0,0,0,0.1,0,0.1c0,0,0,0,0,0.1c0,0.1,0,0.2-0.1,0.3c0,0.1,0,0.1,0,0.2 c0,0.1,0,0.2,0,0.2c-0.3,0.8-1,1.4-1.9,1.4h-78c-1.1,0-2-0.9-2-2L14,34.4l0.1-0.2V34C14.1,32.9,14.9,32,16.1,32L16.1,32z"></path></svg>`;
var ALIAS = `<svg viewBox="0 0 100 100" class="forward-arrow" width="16" height="16"><path fill="currentColor" stroke="currentColor" d="m9.9,89.09226c-0.03094,0 -0.05414,0 -0.08508,0c-1.06734,-0.04641 -1.91039,-0.92812 -1.89492,-1.99547c0.00774,-0.48726 1.14469,-48.13101 47.52,-49.44586l0,-13.89094c0,-0.7657 0.44086,-1.4618 1.12922,-1.78664c0.68062,-0.33258 1.5082,-0.23203 2.09601,0.2475l31.68,25.74c0.46406,0.37899 0.73476,0.9436 0.73476,1.53914c0,0.59555 -0.2707,1.16016 -0.72703,1.53914l-31.68,25.74c-0.59555,0.47953 -1.41539,0.57234 -2.10375,0.2475c-0.68836,-0.32485 -1.12922,-1.02094 -1.12922,-1.78664l0,-13.84453c-41.26289,0.75024 -43.49039,24.81961 -43.56773,25.85601c-0.06961,1.04414 -0.93586,1.84078 -1.97226,1.84078z"></path></svg>`;
var TAG = `<svg viewBox="0 0 100 100" class="hashtag" width="17" height="17"><path fill="currentColor" stroke="currentColor" d="M36,18l-1.5,16H20l-0.4,4h14.5l-2.4,26H17.2l-0.4,4h14.5L30,82h4l1.3-14h26L60,82h4l1.3-14h15.5l0.4-4H65.7l2.4-26h15.5 l0.4-4H68.5L70,18h-4l-1.5,16h-26L40,18L36,18z M38.1,38h26l-2.4,26h-26L38.1,38z"></path></svg>`;
var LINK = `<svg viewBox="0 0 100 100" class="links-going-out" width="15" height="15"><path fill="currentColor" stroke="currentColor" d="M76.4,11.7c3.7,3.8,5.6,8.9,5,14.3c-0.5,4-2.4,7.6-5.2,10.5c-2.6,2.6-6.7,6.7-9.2,9.2c-2,2-4.4,3.6-7.1,4.5 c-4.5,1.4-9,1-12.8-0.9l2.9-2.9c1.4,0.5,3,0.8,4.5,0.8c3.6,0,7-1.4,9.5-3.9l9.6-9.6c3.3-3.3,4.7-8.1,3.5-13 c-0.3-1.2-0.8-2.4-1.5-3.5C73,13,68.7,10.6,64,10.6c-3.6,0-7,1.4-9.5,3.9L45,24c-2.5,2.5-3.9,5.9-3.9,9.5c0,1.6,0.3,3.1,0.8,4.5 l-3,3c-1.1-2.3-1.7-4.8-1.7-7.5c0-0.7,0-1.4,0.1-2.1c0.5-3.8,2.2-7.4,5-10.2l9.4-9.4C54.5,9,58.2,7,62.1,6.6 C67.5,6.1,72.6,7.9,76.4,11.7L76.4,11.7z M54.4,34.7c0.3,0.7,0.1,1.6-0.4,2.1L30.9,59.9c-0.5,0.5-1.2,0.7-1.9,0.5 s-1.2-0.7-1.4-1.4s0-1.4,0.5-1.9L51.2,34c0.3-0.4,0.8-0.6,1.3-0.6C53.4,33.5,54.1,34,54.4,34.7z M35.1,44.9l-2.9,2.9 c-1.4-0.5-3-0.8-4.5-0.8c-3.6,0-7,1.4-9.5,3.9l-9.6,9.6c-3.3,3.4-4.7,8.1-3.5,13c0.3,1.2,0.8,2.4,1.5,3.5 c2.6,4.2,6.9,6.6,11.6,6.6c3.6,0,7-1.4,9.5-3.9l9.6-9.6c2.5-2.5,3.9-5.9,3.9-9.5c0-1.6-0.3-3.1-0.8-4.5l2.9-2.9 c1.1,2.3,1.7,4.8,1.7,7.5c0,3-0.8,5.9-2.2,8.5c-0.8,1-1.5,1.9-2.1,2.9c-0.3,0.3-0.5,0.6-0.8,0.8l-9.4,9.4 c-2.9,2.9-6.6,4.8-10.6,5.2c-6.2,0.6-12-1.9-15.8-6.9c-2.4-3.2-3.6-7.2-3.4-11.2c0-0.1,0-0.2,0-0.3c0.3-4.2,2-8.1,5-11.1l9.4-9.4 c2-2,4.4-3.6,7.1-4.5C26.8,42.6,31.3,43,35.1,44.9L35.1,44.9z"></path><path fill="currentColor" stroke="currentColor" d="M99.2,69.3c0-0.2,0-0.2,0-0.4c0-0.2,0-0.2,0-0.4s0-0.2-0.2-0.4c0-0.2,0-0.2-0.2-0.4l0,0l-0.2-0.2l-0.2-0.2L79.2,53 c-0.6-0.4-1.3-0.6-1.9-0.2c-0.8,0.4-1.2,1-1.2,1.7V62c-8.1,0.4-14.6,3.1-19.2,8.1c-8.5,9-7.7,22.5-7.7,23.1c0,0.2,0,0.2,0,0.4 c0,0.2,0,0.2,0,0.4s0.2,0.2,0.2,0.4l0.2,0.2c0.2,0.2,0.2,0.2,0.4,0.2l0.2,0.2c0.2,0,0.4,0,0.6,0.2H51l0,0l0,0c0,0,0,0,0.2,0 s0.2,0,0.4,0s0.2,0,0.4-0.2c0.2,0,0.2-0.2,0.4-0.2s0.2-0.2,0.4-0.2c0,0,0.2-0.2,0.2-0.4c0-0.2,0.2-0.2,0.2-0.4s0-0.2,0-0.4 c0-0.2,0-0.2,0-0.4c0-0.8,0.6-16.6,23.1-17.5v7.3c0,0.8,0.4,1.3,1,1.7c0.6,0.4,1.3,0.2,1.9-0.2l19.2-14l0.2-0.2l0.2-0.2l0,0 c0-0.2,0.2-0.2,0.2-0.4L99.2,69.3L99.2,69.3z"></path></svg>`;
var HEADER = `<svg viewBox="0 0 100 100" class="bullet-list" width="15" height="15"><path fill="currentColor" stroke="currentColor" d="M16.4,16.4c-3.5,0-6.4,2.9-6.4,6.4s2.9,6.4,6.4,6.4s6.4-2.9,6.4-6.4S19.9,16.4,16.4,16.4z M16.4,19.6 c1.8,0,3.2,1.4,3.2,3.2c0,1.8-1.4,3.2-3.2,3.2s-3.2-1.4-3.2-3.2C13.2,21,14.6,19.6,16.4,19.6z M29.2,21.2v3.2H90v-3.2H29.2z M16.4,43.6c-3.5,0-6.4,2.9-6.4,6.4s2.9,6.4,6.4,6.4s6.4-2.9,6.4-6.4S19.9,43.6,16.4,43.6z M16.4,46.8c1.8,0,3.2,1.4,3.2,3.2 s-1.4,3.2-3.2,3.2s-3.2-1.4-3.2-3.2S14.6,46.8,16.4,46.8z M29.2,48.4v3.2H90v-3.2H29.2z M16.4,70.8c-3.5,0-6.4,2.9-6.4,6.4 c0,3.5,2.9,6.4,6.4,6.4s6.4-2.9,6.4-6.4C22.8,73.7,19.9,70.8,16.4,70.8z M16.4,74c1.8,0,3.2,1.4,3.2,3.2c0,1.8-1.4,3.2-3.2,3.2 s-3.2-1.4-3.2-3.2C13.2,75.4,14.6,74,16.4,74z M29.2,75.6v3.2H90v-3.2H29.2z"></path></svg>`;
var SEARCH = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v3"></path>
  <polyline points="14 2 14 8 20 8"></polyline>
  <path d="M5 17a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"></path>
  <path d="m9 18-1.5-1.5"></path>
</svg>`;
var FILTER = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
</svg>`;
var FRONT_MATTER = `<svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 20 20"><g fill="none"><path d="M10.32 2.013A4 4 0 0 0 6.162 7.13l-3.987 3.986a.6.6 0 0 0-.176.424V14.4a.6.6 0 0 0 .6.6h2.8a.6.6 0 0 0 .6-.6V13h1.9a.6.6 0 0 0 .6-.6v-1.693l.735-.735a5.51 5.51 0 0 1-.569-.846l-.99.991a.6.6 0 0 0-.176.424V12H5.6a.6.6 0 0 0-.6.6V14H3v-2.293l4.32-4.32l-.118-.303a3.001 3.001 0 0 1 1.96-3.965c.33-.423.72-.796 1.157-1.106zM13.5 6.25a.75.75 0 1 0 0-1.5a.75.75 0 0 0 0 1.5zM9 6.5a4.5 4.5 0 1 1 7 3.742v2.05l.783.784a.6.6 0 0 1 0 .848L15.707 15l1.068 1.067a.6.6 0 0 1-.05.893l-2.35 1.88a.6.6 0 0 1-.75 0l-2.4-1.92a.6.6 0 0 1-.225-.468v-6.21A4.496 4.496 0 0 1 9 6.5zM13.5 3a3.5 3.5 0 0 0-1.75 6.532a.5.5 0 0 1 .25.433v6.295l2 1.6l1.751-1.401l-1.034-1.035a.6.6 0 0 1 0-.848l1.076-1.076l-.617-.617a.6.6 0 0 1-.176-.424V9.965a.5.5 0 0 1 .25-.433A3.5 3.5 0 0 0 13.5 3z" fill="currentColor"></path></g></svg>`;
var PREVIEW = `<svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 20 20"><g fill="none"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5a2 2 0 0 0-2-2zm0 16H5V7h14v12zm-5.5-6c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5zM12 9c-2.73 0-5.06 1.66-6 4c.94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4zm0 6.5a2.5 2.5 0 0 1 0-5a2.5 2.5 0 0 1 0 5z" fill="currentColor"></path></g></svg>`;
var SCORE = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="16" viewBox="0 0 20 20"><g fill="none"><path d="M11 6H9V4h2v2zm4-2h-2v2h2V4zM9 14h2v-2H9v2zm10-4V8h-2v2h2zm0 4v-2h-2v2h2zm-6 0h2v-2h-2v2zm6-10h-2v2h2V4zm-6 4V6h-2v2h2zm-6 2V8h2V6H7V4H5v16h2v-8h2v-2H7zm8 2h2v-2h-2v2zm-4-2v2h2v-2h-2zM9 8v2h2V8H9zm4 2h2V8h-2v2zm2-4v2h2V6h-2z" fill="currentColor"></path></g></svg>`;

// src/ui/modal.ts
function setFloatingModal(appHelper) {
  var _a;
  (_a = activeWindow.activeDocument.querySelector(".modal-bg")) == null ? void 0 : _a.addClass("another-quick-switcher__floating-modal-bg");
  const promptEl = activeWindow.activeDocument.querySelector(".prompt");
  promptEl == null ? void 0 : promptEl.addClass("another-quick-switcher__floating-prompt");
  const fileView = appHelper.getFileViewInActiveLeaf();
  if (fileView) {
    const windowWidth = activeWindow.innerWidth;
    const windowHeight = activeWindow.innerHeight;
    const modalEl = activeWindow.activeDocument.querySelector(
      ".another-quick-switcher__floating-prompt"
    );
    if (!modalEl) {
      console.error("Unexpected error.");
      return;
    }
    const selector = fileView.getState().mode === "preview" ? ".markdown-preview-sizer" : ".cm-sizer";
    const editorContentEl = fileView.contentEl.querySelector(selector);
    if (!editorContentEl) {
      console.error("Unexpected error.");
      return;
    }
    const { width: modalWidth, height: modalHeight } = modalEl.getBoundingClientRect();
    const { x: contentX, width: contentWidth } = editorContentEl.getBoundingClientRect();
    const { y: leafY } = fileView.containerEl.getBoundingClientRect();
    const { y: promptY } = promptEl.getBoundingClientRect();
    const contentXEnd = contentX + contentWidth;
    const left = windowWidth - contentXEnd - 30 > modalWidth ? contentXEnd - 30 : contentX - modalWidth - 30 > 0 ? contentX - modalWidth : windowWidth - modalWidth - 30;
    const top = Math.min(windowHeight - modalHeight - 10, leafY + promptY);
    promptEl == null ? void 0 : promptEl.setAttribute("style", `left: ${left}px; top: ${top}px`);
  }
}

// src/utils/math.ts
function round(n, decimalPlace) {
  const x = 10 ** decimalPlace;
  return Math.round(n * x) / x;
}

// src/ui/suggestion-factory.ts
function createItemDiv(item, aliasesDisplayedAsTitle, options) {
  var _a, _b;
  const itemDiv = createDiv({
    cls: [
      "another-quick-switcher__item",
      item.phantom ? "another-quick-switcher__phantom_item" : "",
      item.starred ? "another-quick-switcher__starred_item" : "",
      options.hideGutterIcons ? "another-quick-switcher__gutter_hidden" : ""
    ].filter((x) => x),
    attr: {
      extension: item.file.extension
    }
  });
  const entryDiv = createDiv({
    cls: "another-quick-switcher__item__entry"
  });
  const shouldShowAliasAsTitle = aliasesDisplayedAsTitle.length > 0 && (options.displayAliaseAsTitle || options.displayAliasAsTitleOnKeywordMatched);
  const titleDiv = createDiv({
    cls: "another-quick-switcher__item__title",
    text: shouldShowAliasAsTitle ? aliasesDisplayedAsTitle.join(" / ") : item.file.basename
  });
  entryDiv.appendChild(titleDiv);
  const isExcalidrawFile = isExcalidraw(item.file);
  if (item.file.extension !== "md" || isExcalidrawFile) {
    const extDiv = createDiv({
      cls: "another-quick-switcher__item__extension",
      text: isExcalidrawFile ? "excalidraw" : item.file.extension
    });
    titleDiv.appendChild(extDiv);
  }
  if (item.order < 9) {
    const hotKeyGuide = createSpan({
      cls: "another-quick-switcher__item__hot-key-guide",
      text: `${item.order + 1}`
    });
    entryDiv.appendChild(hotKeyGuide);
  }
  if (options.showDirectory) {
    const directoryDiv = createDiv({
      cls: "another-quick-switcher__item__directory"
    });
    directoryDiv.insertAdjacentHTML("beforeend", FOLDER);
    const text = options.showFullPathOfDirectory ? (_a = item.file.parent) == null ? void 0 : _a.path : (_b = item.file.parent) == null ? void 0 : _b.name;
    directoryDiv.appendText(` ${text}`);
    entryDiv.appendChild(directoryDiv);
    if (options.showDirectoryAtNewLine) {
      itemDiv.appendChild(entryDiv);
      itemDiv.appendChild(directoryDiv);
      return itemDiv;
    }
  }
  itemDiv.appendChild(entryDiv);
  return itemDiv;
}
function createMetaDiv(args) {
  const { frontMatter, options } = args;
  const metaDiv = createDiv({
    cls: "another-quick-switcher__item__metas"
  });
  if (options.showFuzzyMatchScore && args.score > 0) {
    const scoreDiv = createDiv({
      cls: "another-quick-switcher__item__meta"
    });
    const scoreSpan = createSpan({
      cls: "another-quick-switcher__item__meta__score"
    });
    scoreSpan.insertAdjacentHTML("beforeend", SCORE);
    scoreSpan.appendText(String(args.score));
    scoreDiv.appendChild(scoreSpan);
    metaDiv.appendChild(scoreDiv);
  }
  if (options.showFrontMatter && Object.keys(frontMatter).length > 0) {
    const frontMattersDiv = createDiv({
      cls: "another-quick-switcher__item__meta"
    });
    for (const [key, value] of Object.entries(frontMatter)) {
      const frontMatterDiv = createDiv({
        cls: "another-quick-switcher__item__meta__front_matter",
        title: `${key}: ${value}`
      });
      frontMatterDiv.insertAdjacentHTML("beforeend", FRONT_MATTER);
      frontMatterDiv.createSpan({
        cls: "another-quick-switcher__item__meta__front_matter__key",
        title: key,
        text: key
      });
      for (const v of [value].flat().filter(isPresent)) {
        frontMatterDiv.createSpan({
          cls: "another-quick-switcher__item__meta__front_matter__value",
          title: v.toString(),
          text: v.toString()
        });
      }
      frontMattersDiv.appendChild(frontMatterDiv);
    }
    metaDiv.appendChild(frontMattersDiv);
  }
  return metaDiv;
}
function createDescriptionDiv(args) {
  const {
    item,
    aliases,
    tags,
    countByLink,
    countByHeader,
    linkResultsNum,
    headerResultsNum,
    options
  } = args;
  const descriptionDiv = createDiv({
    cls: "another-quick-switcher__item__descriptions"
  });
  if (aliases.length > 0) {
    const aliasDiv = createDiv({
      cls: "another-quick-switcher__item__description"
    });
    const displayAliases = options.displayAliasAsTitleOnKeywordMatched ? [item.file.basename] : aliases;
    for (const x of displayAliases) {
      const aliasSpan = createSpan({
        cls: "another-quick-switcher__item__description__alias"
      });
      aliasSpan.insertAdjacentHTML("beforeend", ALIAS);
      aliasSpan.appendText(x);
      aliasDiv.appendChild(aliasSpan);
    }
    descriptionDiv.appendChild(aliasDiv);
  }
  if (tags.length > 0) {
    const tagsDiv = createDiv({
      cls: "another-quick-switcher__item__description"
    });
    for (const x of tags) {
      const tagsSpan = createSpan({
        cls: "another-quick-switcher__item__description__tag"
      });
      tagsSpan.insertAdjacentHTML("beforeend", TAG);
      tagsSpan.appendText(x.replace("#", ""));
      tagsDiv.appendChild(tagsSpan);
    }
    descriptionDiv.appendChild(tagsDiv);
  }
  if (Object.keys(countByLink).length > 0) {
    const linksDiv = createDiv({
      cls: "another-quick-switcher__item__description"
    });
    const linkAndCount = Object.entries(countByLink).map(([link, n]) => ({ link, n })).sort((a, b) => b.n - a.n);
    for (const { link, n } of linkAndCount) {
      const linkSpan = createSpan({
        cls: [
          "another-quick-switcher__item__description__link",
          n !== linkResultsNum ? "another-quick-switcher__item__description__link__dimmed" : ""
        ]
      });
      linkSpan.insertAdjacentHTML("beforeend", LINK);
      linkSpan.appendChild(
        createSpan({ text: link, attr: { style: "padding-left: 3px" } })
      );
      linksDiv.appendChild(linkSpan);
    }
    descriptionDiv.appendChild(linksDiv);
  }
  if (Object.keys(countByHeader).length > 0) {
    const headersDiv = createDiv({
      cls: "another-quick-switcher__item__description"
    });
    const headerAndCount = Object.entries(countByHeader).map(([header, n]) => ({ header, n })).sort((a, b) => b.n - a.n);
    for (const { header, n } of headerAndCount) {
      const headersSpan = createSpan({
        cls: [
          "another-quick-switcher__item__description__header",
          n !== headerResultsNum ? "another-quick-switcher__item__description__header__dimmed" : ""
        ]
      });
      headersSpan.insertAdjacentHTML("beforeend", HEADER);
      headersSpan.appendChild(
        createSpan({ text: header, attr: { style: "padding-left: 3px" } })
      );
      headersDiv.appendChild(headersSpan);
    }
    descriptionDiv.appendChild(headersDiv);
  }
  return descriptionDiv;
}
function createElements(item, options) {
  var _a;
  const { title, aliases } = getMatchedTitleAndAliases(item);
  const matchedAliasesOnly = title ? [] : aliases;
  const itemDiv = createItemDiv(
    item,
    options.displayAliaseAsTitle ? item.aliases : matchedAliasesOnly,
    options
  );
  const frontMatter = omitBy(
    (_a = item.frontMatter) != null ? _a : {},
    (key, value) => options.excludeFrontMatterKeys.includes(key) || value == null
  );
  const maxScore = round(
    Math.max(...item.matchResults.map((a) => {
      var _a2;
      return (_a2 = a.score) != null ? _a2 : 0;
    })),
    6
  );
  const metaDiv = Object.keys(frontMatter).length > 0 || maxScore > 0 ? createMetaDiv({
    frontMatter,
    score: maxScore,
    options
  }) : void 0;
  const tags = uniqFlatMap(
    item.matchResults.filter((res) => res.type === "tag"),
    (x) => {
      var _a2;
      return (_a2 = x.meta) != null ? _a2 : [];
    }
  );
  const linkResults = item.matchResults.filter((res) => res.type === "link");
  const linkResultsNum = linkResults.length;
  const countByLink = count(linkResults.flatMap((xs) => {
    var _a2;
    return uniq((_a2 = xs.meta) != null ? _a2 : []);
  }));
  const headerResults = item.matchResults.filter(
    (res) => res.type === "header"
  );
  const headerResultsNum = headerResults.length;
  const countByHeader = count(
    headerResults.flatMap((xs) => {
      var _a2;
      return uniq((_a2 = xs.meta) != null ? _a2 : []);
    })
  );
  const descriptionDiv = aliases.length !== 0 || tags.length !== 0 || Object.keys(countByLink).length !== 0 || Object.keys(countByHeader).length !== 0 ? createDescriptionDiv({
    item,
    aliases: matchedAliasesOnly,
    tags,
    countByLink,
    countByHeader,
    linkResultsNum,
    headerResultsNum,
    options
  }) : void 0;
  return {
    itemDiv,
    metaDiv,
    descriptionDiv
  };
}

// src/ui/AnotherQuickSwitcherModal.ts
var globalInternalStorage = {
  query: ""
};
var AnotherQuickSwitcherModal = class _AnotherQuickSwitcherModal extends import_obsidian4.SuggestModal {
  constructor(args) {
    var _a;
    super(args.app);
    this.willSilentClose = false;
    this.historyRestoreStatus = "initial";
    this.isClosed = new Promise((resolve) => {
      this.markClosed = resolve;
    });
    this.modalEl.addClass("another-quick-switcher__modal-prompt");
    this.appHelper = new AppHelper(args.app);
    this.settings = args.settings;
    this.logger = Logger.of(this.settings);
    this.initialCommand = args.command;
    this.command = args.command;
    this.originFile = args.originFile;
    this.floating = args.command.floating;
    this.initialInputQuery = args.inputQuery;
    this.navigationHistories = args.navigationHistories;
    this.currentNavigationHistoryIndex = args.currentNavigationHistoryIndex;
    this.stackHistory = args.stackHistory;
    this.initialLeaf = args.initialLeaf;
    this.stateToRestore = args.initialState;
    this.navQueue = (_a = args.navQueue) != null ? _a : Promise.resolve();
    this.limit = this.settings.maxNumberOfSuggestions;
    this.setHotkeys();
    this.phantomItems = this.settings.showExistingFilesOnly ? [] : this.appHelper.searchPhantomFiles().map((x) => ({
      file: x,
      aliases: [],
      tags: [],
      headers: [],
      links: [],
      phantom: true,
      starred: false,
      matchResults: [],
      tokens: x.basename.split(" ")
    }));
    this.indexingItems();
    this.debounceGetSuggestions = (0, import_obsidian4.debounce)(
      (query, cb) => {
        cb(this._getSuggestions(query));
      },
      this.settings.searchDelayMilliSeconds,
      true
    );
  }
  close() {
    if (import_obsidian4.Platform.isMobile) {
      this.onClose();
    }
    super.close();
  }
  safeClose() {
    this.close();
    return this.isClosed;
  }
  silentClose() {
    this.willSilentClose = true;
    this.close();
  }
  onOpen() {
    var _a, _b;
    this.isOpen = true;
    this.inputEl.value = this.command.restoreLastInput ? (_a = this.initialInputQuery) != null ? _a : globalInternalStorage.query : (_b = this.initialInputQuery) != null ? _b : "";
    this.inputEl.select();
    this.updateSuggestions();
    if (this.command.floating) {
      this.enableFloating();
    }
    if (this.stackHistory) {
      this.navigationHistories.push({
        inputQuery: this.inputEl.value,
        command: { ...this.command },
        originFile: this.originFile
      });
    }
    this.opened = true;
  }
  onClose() {
    super.onClose();
    if (this.willSilentClose) {
      return;
    }
    if (this.command.restoreLastInput) {
      globalInternalStorage.query = this.inputEl.value;
    }
    if (this.stateToRestore) {
      this.navigate(() => this.stateToRestore.restore());
    }
    this.navigate(this.markClosed);
  }
  enableFloating() {
    this.floating = true;
    if (!import_obsidian4.Platform.isPhone) {
      setFloatingModal(this.appHelper);
    }
  }
  indexingItems() {
    var _a;
    const starredPathMap = keyBy(
      this.appHelper.getStarredFilePaths(),
      (x) => x
    );
    const originFilePath = (_a = this.originFile) == null ? void 0 : _a.path;
    let start = performance.now();
    const fileItems = this.app.vault.getFiles().filter(
      (x) => x.path !== originFilePath && this.app.metadataCache.getFileCache(x)
    ).map((x) => {
      var _a2, _b, _c, _d, _e, _f;
      const cache = this.app.metadataCache.getFileCache(x);
      return {
        file: x,
        aliases: (_a2 = (0, import_obsidian4.parseFrontMatterAliases)(cache.frontmatter)) != null ? _a2 : [],
        tags: this.command.searchBy.tag ? uniq([
          ...((_b = cache.tags) != null ? _b : []).map((x2) => x2.tag),
          ...(_c = (0, import_obsidian4.parseFrontMatterTags)(cache.frontmatter)) != null ? _c : []
        ]) : [],
        headers: this.command.searchBy.header ? ((_d = cache.headings) != null ? _d : []).map((x2) => excludeFormat(x2.heading)) : [],
        links: this.command.searchBy.link ? uniq(
          [
            ...(_e = cache.links) != null ? _e : [],
            ...(_f = cache.frontmatterLinks) != null ? _f : []
          ].map((x2) => {
            var _a3;
            return (_a3 = x2.displayText) != null ? _a3 : "";
          })
        ) : [],
        frontMatter: (this.command.showFrontMatter || this.command.searchBy.property) && cache.frontmatter ? omitBy(cache.frontmatter, (key, _) => key === "position") : void 0,
        phantom: false,
        starred: x.path in starredPathMap,
        matchResults: [],
        tokens: x.basename.split(" ")
      };
    });
    this.logger.showDebugLog("Indexing file items: ", start);
    this.originItems = [...fileItems, ...this.phantomItems];
    start = performance.now();
    this.ignoredItems = this.prefilterItems(this.command);
    this.logger.showDebugLog("Prefilter items: ", start);
  }
  prefilterItems(command) {
    const filterItems = (includePatterns, excludePatterns) => {
      let items = this.originItems;
      if (command.targetExtensions.length > 0) {
        items = items.filter(
          (x) => command.targetExtensions.includes(x.file.extension)
        );
      }
      switch (command.searchTarget) {
        case "file":
          break;
        case "opened file": {
          const paths = this.appHelper.getFilePathsInActiveWindow();
          items = items.filter((x) => paths.includes(x.file.path));
          break;
        }
        case "backlink": {
          const backlinksMap = this.appHelper.createBacklinksMap();
          items = items.filter(
            (x) => {
              var _a, _b, _c;
              return (_c = backlinksMap[(_b = (_a = this.originFile) == null ? void 0 : _a.path) != null ? _b : ""]) == null ? void 0 : _c.has(x.file.path);
            }
          );
          break;
        }
        case "link": {
          const originFileLinkMap = this.originFile ? this.appHelper.createLinksMap(this.originFile) : {};
          items = items.filter((x) => originFileLinkMap[x.file.path]).sort(
            sorter((x) => {
              const c = originFileLinkMap[x.file.path];
              return isFrontMatterLinkCache(c) ? -1 : c.position.start.offset;
            })
          );
          break;
        }
        case "2-hop-link": {
          const backlinksMap2 = this.appHelper.createBacklinksMap();
          const originFileLinkMap2 = this.originFile ? this.appHelper.createLinksMap(this.originFile) : {};
          const linkPaths = items.filter((x) => originFileLinkMap2[x.file.path]).map((x) => x.file.path);
          const backlinkPaths = linkPaths.flatMap(
            (x) => Array.from(backlinksMap2[x])
          );
          const filteredPaths = uniq([...linkPaths, ...backlinkPaths]);
          items = items.filter((x) => filteredPaths.includes(x.file.path)).sort(
            sorter((x) => {
              const c = originFileLinkMap2[x.file.path];
              return !c || isFrontMatterLinkCache(c) ? 65535 : c.position.start.offset;
            })
          );
          break;
        }
      }
      if (includePatterns.length > 0) {
        items = includeItems(items, includePatterns, (x) => x.file.path);
      }
      if (excludePatterns.length > 0) {
        items = excludeItems(items, excludePatterns, (x) => x.file.path);
      }
      return items;
    };
    return filterItems(
      command.includePrefixPathPatterns.map(
        (p) => p.replace(/<current_dir>/g, this.appHelper.getCurrentDirPath())
      ),
      command.excludePrefixPathPatterns.map(
        (p) => p.replace(/<current_dir>/g, this.appHelper.getCurrentDirPath())
      )
    );
  }
  getSuggestions(query) {
    if (!query || query === this.command.defaultInput || !this.opened) {
      return this._getSuggestions(query);
    }
    return new Promise((resolve) => {
      this.debounceGetSuggestions(query, (items) => {
        resolve(items);
      });
    });
  }
  _getSuggestions(query) {
    var _a;
    const start = performance.now();
    const lastOpenFileIndexByPath = {};
    this.app.workspace.getLastOpenFiles().forEach((v, i) => {
      lastOpenFileIndexByPath[v] = i;
    });
    const commandByPrefix = this.settings.searchCommands.filter((x) => x.commandPrefix).find((x) => query.startsWith(x.commandPrefix));
    if ((commandByPrefix || this.initialCommand !== this.command) && commandByPrefix !== this.command) {
      this.command = commandByPrefix != null ? commandByPrefix : this.initialCommand;
      this.indexingItems();
    }
    this.searchQuery = query.startsWith(this.command.commandPrefix) ? query.replace(this.command.commandPrefix, "") : query;
    this.searchQuery = this.searchQuery.replace(
      /<cd>/g,
      this.appHelper.getCurrentDirPath()
    );
    if (this.command.defaultInput) {
      this.searchQuery = `${this.command.defaultInput}${this.searchQuery}`;
    }
    this.renderInputComponent();
    const qs = smartWhitespaceSplit(this.searchQuery);
    if (this.command.searchTarget === "backlink" && !((_a = this.originFile) == null ? void 0 : _a.path)) {
      return [];
    }
    const isQueryEmpty = !this.searchQuery.trim();
    const matchedSuggestions = isQueryEmpty ? this.ignoredItems : this.ignoredItems.map(
      (x) => stampMatchResults(x, qs, {
        isNormalizeAccentsDiacritics: this.settings.normalizeAccentsAndDiacritics,
        searchByHeaders: this.command.searchBy.header,
        searchByLinks: this.command.searchBy.link,
        searchByTags: this.command.searchBy.tag,
        keysOfPropertyToSearch: this.command.searchBy.property ? this.command.keysOfPropertyToSearch : [],
        fuzzyTarget: this.command.allowFuzzySearchForSearchTarget,
        minFuzzyScore: this.command.minFuzzyMatchScore
      })
    ).filter((x) => x.matchResults.every((x2) => x2.type !== "not found"));
    const items = sort(
      matchedSuggestions,
      isQueryEmpty ? filterNoQueryPriorities(this.command.sortPriorities) : this.command.sortPriorities,
      lastOpenFileIndexByPath
    );
    this.logger.showDebugLog(
      `Get suggestions: ${this.searchQuery} (${this.command.name})`,
      start
    );
    this.countInputEl = createDiv({
      text: `${Math.min(items.length, this.limit)} / ${items.length}`,
      cls: "another-quick-switcher__status__count-input"
    });
    this.inputEl.before(this.countInputEl);
    return items.slice(0, this.limit).map((x, order) => ({ ...x, order }));
  }
  renderInputComponent() {
    var _a, _b, _c, _d;
    (_a = this.navigationHistoryEl) == null ? void 0 : _a.remove();
    (_b = this.searchCommandEl) == null ? void 0 : _b.remove();
    (_c = this.defaultInputEl) == null ? void 0 : _c.remove();
    (_d = this.countInputEl) == null ? void 0 : _d.remove();
    this.navigationHistoryEl = createDiv({
      cls: "another-quick-switcher__custom-search__navigation-history-header"
    });
    const backHistoryLength = this.currentNavigationHistoryIndex;
    if (backHistoryLength > 0) {
      this.navigationHistoryEl.appendText(`${backHistoryLength} < `);
    }
    this.navigationHistoryEl.appendText(
      this.originFile ? this.originFile.basename : "No file"
    );
    const forwardHistoryLength = this.navigationHistories.length - this.currentNavigationHistoryIndex - 1;
    if (forwardHistoryLength > 0) {
      this.navigationHistoryEl.appendText(` > ${forwardHistoryLength}`);
    }
    this.inputEl.before(this.navigationHistoryEl);
    this.searchCommandEl = createDiv({
      cls: "another-quick-switcher__status__search-command"
    });
    this.searchCommandEl.insertAdjacentHTML("beforeend", SEARCH);
    this.searchCommandEl.createSpan({
      text: this.command.name,
      cls: "another-quick-switcher__status__search-command-name"
    });
    this.searchCommandEl.createSpan({
      cls: "another-quick-switcher__status__search-command-separator"
    });
    if (this.command.searchBy.tag) {
      this.searchCommandEl.insertAdjacentHTML("beforeend", TAG);
    }
    if (this.command.searchBy.header) {
      this.searchCommandEl.insertAdjacentHTML("beforeend", HEADER);
    }
    if (this.command.searchBy.link) {
      this.searchCommandEl.insertAdjacentHTML("beforeend", LINK);
    }
    const promptInputContainer = this.modalEl.find(".prompt-input-container");
    if (promptInputContainer) {
      promptInputContainer.setAttr("style", "display: initial");
    }
    this.inputEl.before(this.searchCommandEl);
    if (this.command.defaultInput) {
      this.defaultInputEl = createDiv({
        text: this.searchQuery,
        cls: "another-quick-switcher__status__default-input"
      });
      this.defaultInputEl.insertAdjacentHTML("afterbegin", FILTER);
      this.resultContainerEl.before(this.defaultInputEl);
    }
  }
  renderSuggestion(item, el) {
    const { itemDiv, metaDiv, descriptionDiv } = createElements(item, {
      showFrontMatter: this.command.showFrontMatter,
      excludeFrontMatterKeys: this.command.excludeFrontMatterKeys,
      showDirectory: this.settings.showDirectory,
      showDirectoryAtNewLine: this.settings.showDirectoryAtNewLine,
      showFullPathOfDirectory: this.settings.showFullPathOfDirectory,
      displayAliasAsTitleOnKeywordMatched: this.settings.showAliasesOnTop,
      displayAliaseAsTitle: this.settings.displayAliaseAsTitle,
      hideGutterIcons: this.settings.hideGutterIcons,
      showFuzzyMatchScore: this.settings.showFuzzyMatchScore
    });
    if (metaDiv == null ? void 0 : metaDiv.hasChildNodes()) {
      itemDiv.appendChild(metaDiv);
    }
    if (descriptionDiv == null ? void 0 : descriptionDiv.hasChildNodes()) {
      itemDiv.appendChild(descriptionDiv);
    }
    el.appendChild(itemDiv);
  }
  onNoSuggestion() {
    super.onNoSuggestion();
    const div = createDiv({
      cls: "another-quick-switcher__command_buttons"
    });
    const createButton = createEl("button", {
      text: "Create",
      cls: "another-quick-switcher__command_button"
    });
    createButton.addEventListener(
      "click",
      () => this.handleCreateNewMarkdown(this.searchQuery, "same-tab")
    );
    div.appendChild(createButton);
    const searchInGoogleButton = createEl("button", {
      text: "Search in google",
      cls: "another-quick-switcher__command_button"
    });
    searchInGoogleButton.addEventListener("click", () => {
      activeWindow.open(`https://www.google.com/search?q=${this.searchQuery}`);
      this.close();
    });
    div.appendChild(searchInGoogleButton);
    this.resultContainerEl.appendChild(div);
  }
  navigate(cb) {
    this.navQueue = this.navQueue.then(cb);
  }
  async chooseCurrentSuggestion(leafType, option = {}) {
    var _a, _b, _c, _d, _e, _f;
    const item = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem];
    if (!item) {
      return null;
    }
    let fileToOpened = item.file;
    if (item.phantom) {
      fileToOpened = await this.app.vault.create(item.file.path, "");
    }
    let offset;
    let leafPriorToSameTab;
    switch (this.command.searchTarget) {
      case "file":
        if (((_b = item.matchResults[0]) == null ? void 0 : _b.type) === "header") {
          const firstHeader = item.matchResults[0].meta[0];
          offset = (_c = this.appHelper.findFirstHeaderOffset(item.file, firstHeader)) != null ? _c : void 0;
        }
        break;
      case "opened file":
        if (((_d = item.matchResults[0]) == null ? void 0 : _d.type) === "header") {
          const firstHeader = item.matchResults[0].meta[0];
          offset = (_e = this.appHelper.findFirstHeaderOffset(item.file, firstHeader)) != null ? _e : void 0;
        }
        this.appHelper.getFilePathsInActiveWindow;
        leafPriorToSameTab = this.appHelper.findLeaf(fileToOpened);
        break;
      case "backlink":
        offset = this.appHelper.findFirstLinkOffset(
          item.file,
          this.originFile
        );
        break;
      case "link":
        break;
      case "2-hop-link":
        break;
      default:
        throw new ExhaustiveError(this.command.searchTarget);
    }
    if (!option.keepOpen) {
      this.close();
      this.navigate(() => this.isClosed);
    } else if (leafType === "same-tab") {
      (_f = this.stateToRestore) != null ? _f : this.stateToRestore = this.appHelper.captureState(this.initialLeaf);
    }
    this.navigate(
      () => this.appHelper.openFile(
        fileToOpened,
        {
          leafType,
          offset,
          inplace: option.keepOpen,
          preventDuplicateTabs: this.settings.preventDuplicateTabs,
          leafPriorToSameTab
        },
        this.stateToRestore
      )
    );
    return fileToOpened;
  }
  async onChooseSuggestion() {
    await this.chooseCurrentSuggestion("same-tab");
  }
  async handleCreateNewMarkdown(searchQuery, leafType) {
    if (!searchQuery) {
      return true;
    }
    const file = await this.appHelper.createMarkdown(this.searchQuery);
    if (!file) {
      new import_obsidian4.Notice("This file already exists.");
      return true;
    }
    this.close();
    this.navigate(() => this.isClosed);
    this.navigate(() => this.appHelper.openFile(file, { leafType }));
    return false;
  }
  registerKeys(key, handler) {
    var _a;
    for (const x of (_a = this.settings.hotkeys.main[key]) != null ? _a : []) {
      this.scope.register(
        x.modifiers,
        normalizeKey(capitalizeFirstLetter(x.key)),
        (evt) => {
          if (!evt.isComposing) {
            evt.preventDefault();
            handler();
            return false;
          }
        }
      );
    }
  }
  setHotkeys() {
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Enter"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Escape"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Home"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "End"));
    const openNthMod = quickResultSelectionModifier(
      this.settings.userAltInsteadOfModForQuickResultSelection
    );
    if (!this.settings.hideHotkeyGuides) {
      this.setInstructions([
        { command: "[\u2191]", purpose: "up" },
        { command: "[\u2193]", purpose: "down" },
        { command: `[${openNthMod} 1~9]`, purpose: "open Nth" },
        ...createInstructions(this.settings.hotkeys.main)
      ]);
    }
    this.registerKeys("up", () => {
      document.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowUp" }));
    });
    this.registerKeys("down", () => {
      document.dispatchEvent(
        new KeyboardEvent("keydown", { key: "ArrowDown" })
      );
    });
    this.registerKeys("clear input", () => {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new Event("input"));
    });
    this.registerKeys("replace input", () => {
      if (this.chooser.values) {
        this.inputEl.value = this.chooser.values[this.chooser.selectedItem].file.basename;
        this.inputEl.dispatchEvent(new Event("input"));
      }
    });
    this.registerKeys("open", async () => {
      await this.chooseCurrentSuggestion("same-tab");
    });
    this.registerKeys("open in new tab", async () => {
      await this.chooseCurrentSuggestion("new-tab");
    });
    this.registerKeys("open in new pane (horizontal)", async () => {
      await this.chooseCurrentSuggestion("new-pane-horizontal");
    });
    this.registerKeys("open in new pane (vertical)", async () => {
      await this.chooseCurrentSuggestion("new-pane-vertical");
    });
    this.registerKeys("open in new window", async () => {
      await this.chooseCurrentSuggestion("new-window");
    });
    this.registerKeys("open in popup", async () => {
      await this.chooseCurrentSuggestion("popup");
    });
    this.registerKeys("open in new tab in background", async () => {
      await this.chooseCurrentSuggestion("new-tab-background", {
        keepOpen: true
      });
    });
    this.registerKeys("open all in new tabs", () => {
      this.close();
      if (this.chooser.values == null) {
        return;
      }
      const items = this.chooser.values.slice().reverse();
      for (const x of items) {
        this.appHelper.openFile(x.file, {
          leafType: "new-tab-background",
          preventDuplicateTabs: this.settings.preventDuplicateTabs
        });
      }
    });
    this.registerKeys("preview", () => {
      if (!this.floating) {
        this.enableFloating();
      }
      this.chooseCurrentSuggestion("same-tab", {
        keepOpen: true
      });
    });
    this.registerKeys("create", async () => {
      await this.handleCreateNewMarkdown(this.searchQuery, "same-tab");
    });
    this.registerKeys("create in new tab", async () => {
      await this.handleCreateNewMarkdown(this.searchQuery, "new-tab");
    });
    this.registerKeys("create in new window", async () => {
      await this.handleCreateNewMarkdown(this.searchQuery, "new-window");
    });
    this.registerKeys("create in new popup", async () => {
      await this.handleCreateNewMarkdown(this.searchQuery, "popup");
    });
    this.registerKeys("open in default app", () => {
      var _a, _b;
      const file = (_b = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem]) == null ? void 0 : _b.file;
      if (!file) {
        return;
      }
      this.appHelper.openFileInDefaultApp(file);
      this.close();
    });
    this.registerKeys("show in system explorer", () => {
      var _a, _b;
      const file = (_b = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem]) == null ? void 0 : _b.file;
      if (!file) {
        return;
      }
      this.appHelper.openInSystemExplorer(file);
      this.close();
    });
    this.registerKeys("open in google", () => {
      activeWindow.open(`https://www.google.com/search?q=${this.searchQuery}`);
      this.close();
    });
    this.registerKeys("open first URL", async () => {
      var _a, _b;
      const fileToOpened = (_b = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem]) == null ? void 0 : _b.file;
      if (!fileToOpened) {
        return;
      }
      this.close();
      await this.isClosed;
      const urls = await this.appHelper.findExternalLinkUrls(fileToOpened);
      if (urls.length > 0) {
        activeWindow.open(urls[0]);
      } else {
        this.appHelper.openFile(fileToOpened, {
          leafType: "same-tab"
        });
      }
    });
    const insertLinkToActiveMarkdownFile = (file, item) => {
      const saat = this.settings.searchesAutoAliasTransform;
      const { title, aliases } = getMatchedTitleAndAliases(item);
      this.appHelper.insertLinkToActiveFileBy(file, {
        phantom: item.phantom,
        displayedString: this.settings.showAliasesOnTop ? title != null ? title : aliases.at(0) : void 0,
        aliasTranformer: saat.enabled ? { pattern: saat.aliasPattern, format: saat.aliasFormat } : void 0
      });
    };
    this.registerKeys("insert to editor", async () => {
      var _a;
      const item = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem];
      if (!item) {
        return;
      }
      const file = item.file;
      if (!file) {
        return;
      }
      await this.safeClose();
      if (this.appHelper.isActiveLeafCanvas()) {
        this.appHelper.addFileToCanvas(file);
      } else {
        insertLinkToActiveMarkdownFile(file, item);
      }
    });
    this.registerKeys("insert to editor in background", async () => {
      var _a;
      const item = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem];
      if (!item) {
        return;
      }
      const file = item.file;
      if (!file) {
        return;
      }
      this.historyRestoreStatus = "doing";
      if (this.stateToRestore) {
        await this.stateToRestore.restore();
        this.stateToRestore = void 0;
      }
      if (this.appHelper.isActiveLeafCanvas()) {
        this.appHelper.addFileToCanvas(file);
      } else {
        insertLinkToActiveMarkdownFile(file, item);
        this.appHelper.insertStringToActiveFile("\n");
      }
    });
    this.registerKeys("insert all to editor", async () => {
      var _a;
      await this.safeClose();
      let offsetX = 0;
      for (const x of (_a = this.chooser.values) != null ? _a : []) {
        if (this.appHelper.isActiveLeafCanvas()) {
          const cv = this.appHelper.addFileToCanvas(x.file, {
            x: offsetX,
            y: 0
          });
          offsetX += cv.width + 30;
        } else {
          insertLinkToActiveMarkdownFile(x.file, x);
          this.appHelper.insertStringToActiveFile("\n");
        }
      }
    });
    const navigateLinks = (command) => {
      var _a, _b;
      const file = (_b = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem]) == null ? void 0 : _b.file;
      if (!file) {
        return;
      }
      this.silentClose();
      const modal = new _AnotherQuickSwitcherModal({
        app: this.app,
        settings: this.settings,
        command: {
          ...command,
          floating: this.floating
        },
        originFile: file,
        inputQuery: null,
        navigationHistories: [
          ...this.navigationHistories.slice(
            0,
            this.currentNavigationHistoryIndex
          ),
          {
            inputQuery: this.inputEl.value,
            command: { ...this.command },
            originFile: this.originFile
          }
        ],
        currentNavigationHistoryIndex: this.currentNavigationHistoryIndex + 1,
        stackHistory: true,
        initialLeaf: this.initialLeaf,
        initialState: this.stateToRestore,
        navQueue: this.navQueue
      });
      modal.open();
    };
    this.registerKeys("show links", () => {
      navigateLinks(createDefaultLinkSearchCommand());
    });
    this.registerKeys("show backlinks", () => {
      navigateLinks(createDefaultBacklinkSearchCommand());
    });
    this.registerKeys("show all results", () => {
      this.limit = Number.MAX_SAFE_INTEGER;
      this.inputEl.dispatchEvent(new Event("input"));
    });
    const navigate = (index) => {
      const history = this.navigationHistories[index];
      if (!history) {
        return;
      }
      this.silentClose();
      const modal = new _AnotherQuickSwitcherModal({
        app: this.app,
        settings: this.settings,
        command: {
          ...history.command,
          floating: this.floating
        },
        originFile: history.originFile,
        inputQuery: history.inputQuery,
        navigationHistories: this.navigationHistories,
        currentNavigationHistoryIndex: index,
        stackHistory: false,
        initialState: this.stateToRestore,
        initialLeaf: this.initialLeaf,
        navQueue: this.navQueue
      });
      modal.open();
    };
    this.registerKeys("navigate back", () => {
      navigate(this.currentNavigationHistoryIndex - 1);
    });
    this.registerKeys("navigate forward", () => {
      navigate(this.currentNavigationHistoryIndex + 1);
    });
    this.registerKeys("close if opened", () => {
      var _a, _b;
      const file = (_b = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem]) == null ? void 0 : _b.file;
      if (!file) {
        return;
      }
      this.appHelper.closeFile(file);
    });
    const modifierKey = this.settings.userAltInsteadOfModForQuickResultSelection ? "Alt" : "Mod";
    for (const n of [1, 2, 3, 4, 5, 6, 7, 8, 9]) {
      this.scope.register([modifierKey], String(n), (evt) => {
        this.chooser.setSelectedItem(n - 1, evt);
        this.chooseCurrentSuggestion("same-tab");
        return false;
      });
    }
    this.registerKeys("dismiss", async () => {
      this.close();
    });
  }
};

// src/ui/BacklinkModal.ts
var import_obsidian5 = require("obsidian");
var BacklinkModal = class extends import_obsidian5.SuggestModal {
  constructor(app, settings, initialLeaf) {
    super(app);
    this.lastOpenFileIndexByPath = {};
    this.suggestions = [];
    this.isClosed = new Promise((resolve) => {
      this.markClosed = resolve;
    });
    this.navQueue = Promise.resolve();
    this.modalEl.addClass("another-quick-switcher__modal-prompt");
    this.vaultRootPath = normalizePath(
      this.app.vault.adapter.basePath
    );
    this.appHelper = new AppHelper(app);
    this.settings = settings;
    this.logger = Logger.of(this.settings);
    this.initialLeaf = initialLeaf;
    this.originFileBaseName = this.appHelper.getActiveFile().basename;
    this.originFileBaseNameRegExp = new RegExp(this.originFileBaseName, "g");
    this.limit = 255;
    this.app.workspace.getLastOpenFiles().forEach((v, i) => {
      this.lastOpenFileIndexByPath[v] = i;
    });
    this.setHotkeys();
    this.debounceGetSuggestions = (0, import_obsidian5.debounce)(
      (query, cb) => {
        cb(this._getSuggestions(query));
      },
      this.settings.searchDelayMilliSeconds,
      true
    );
  }
  async init() {
    await this.indexingItems();
  }
  onOpen() {
    super.onOpen();
    if (!import_obsidian5.Platform.isPhone) {
      setFloatingModal(this.appHelper);
    }
    this.opened = true;
  }
  close() {
    if (import_obsidian5.Platform.isMobile) {
      this.onClose();
    }
    super.close();
  }
  onClose() {
    super.onClose();
    if (this.stateToRestore) {
      this.navigate(() => this.stateToRestore.restore());
    }
    this.navigate(this.markClosed);
  }
  async indexingItems() {
    const start = performance.now();
    const ignoredItems = [];
    const backlinks = this.appHelper.getBacklinksByFilePathInActiveFile();
    if (!backlinks) {
      return;
    }
    for (const [path, caches] of Object.entries(backlinks)) {
      const file = this.appHelper.getFileByPath(path);
      if (this.settings.backlinkExcludePrefixPathPatterns.some(
        (p) => file.path.startsWith(p)
      )) {
        continue;
      }
      const content = await this.app.vault.cachedRead(file);
      for (const cache of caches) {
        ignoredItems.push(
          isFrontMatterLinkCache(cache) ? {
            file,
            line: `<${cache.key}: in properties>`,
            lineNumber: 1,
            offset: 0
          } : {
            file,
            line: content.split("\n").at(cache.position.start.line),
            lineNumber: cache.position.start.line + 1,
            offset: cache.position.start.offset
          }
        );
      }
    }
    this.ignoredItems = uniqBy(
      ignoredItems,
      (item) => `${item.file.path}/${item.lineNumber}`
    );
    this.logger.showDebugLog("Indexing backlinks", start);
  }
  getSuggestions(query) {
    if (!query || !this.opened) {
      return this._getSuggestions(query);
    }
    return new Promise((resolve) => {
      this.debounceGetSuggestions(query, (items) => {
        resolve(items);
      });
    });
  }
  _getSuggestions(query) {
    var _a;
    const start = performance.now();
    const isQueryEmpty = query.trim() === "";
    const queries = query.trim().split(" ");
    const matchedSuggestions = isQueryEmpty ? this.ignoredItems : this.ignoredItems.filter(
      (x) => queries.every(
        (q) => smartIncludes(
          x.file.path,
          q,
          this.settings.normalizeAccentsAndDiacritics
        ) || smartIncludes(
          x.line,
          q,
          this.settings.normalizeAccentsAndDiacritics
        )
      )
    );
    this.logger.showDebugLog(`Get suggestions: ${query}`, start);
    (_a = this.countInputEl) == null ? void 0 : _a.remove();
    this.countInputEl = createDiv({
      text: `${Math.min(matchedSuggestions.length, this.limit)} / ${matchedSuggestions.length}`,
      cls: "another-quick-switcher__backlink__status__count-input"
    });
    this.inputEl.before(this.countInputEl);
    this.suggestions = matchedSuggestions.sort(
      (a, b) => compare(
        a,
        b,
        (x) => {
          var _a2;
          return (_a2 = this.lastOpenFileIndexByPath[x.file.path]) != null ? _a2 : 999999;
        },
        "asc"
      )
    ).slice(0, this.limit).map((x, order) => ({ ...x, order }));
    return this.suggestions;
  }
  renderSuggestion(item, el) {
    var _a, _b, _c;
    const previousPath = (_a = this.suggestions[item.order - 1]) == null ? void 0 : _a.file.path;
    const sameFileWithPrevious = previousPath === item.file.path;
    const itemDiv = createDiv({
      cls: "another-quick-switcher__item"
    });
    const entryDiv = createDiv({
      cls: "another-quick-switcher__item__entry"
    });
    if (!sameFileWithPrevious) {
      const titleDiv = createDiv({
        cls: [
          "another-quick-switcher__item__title",
          "another-quick-switcher__backlink__item__title_entry"
        ],
        text: item.file.basename,
        attr: {
          extension: item.file.extension
        }
      });
      const isExcalidrawFile = isExcalidraw(item.file);
      if (item.file.extension !== "md" || isExcalidrawFile) {
        const extDiv = createDiv({
          cls: "another-quick-switcher__item__extension",
          text: isExcalidrawFile ? "excalidraw" : item.file.extension
        });
        titleDiv.appendChild(extDiv);
      }
      entryDiv.appendChild(titleDiv);
      itemDiv.appendChild(entryDiv);
      if (this.settings.showDirectory) {
        const directoryDiv = createDiv({
          cls: "another-quick-switcher__item__directory"
        });
        directoryDiv.insertAdjacentHTML("beforeend", FOLDER);
        const text = this.settings.showFullPathOfDirectory ? (_b = item.file.parent) == null ? void 0 : _b.path : (_c = item.file.parent) == null ? void 0 : _c.name;
        directoryDiv.appendText(` ${text}`);
        entryDiv.appendChild(directoryDiv);
        if (this.settings.showDirectoryAtNewLine) {
          itemDiv.appendChild(directoryDiv);
        }
      }
    }
    const descriptionsDiv = createDiv({
      cls: "another-quick-switcher__item__descriptions"
    });
    const descriptionDiv = createDiv({
      cls: "another-quick-switcher__backlink__item__description"
    });
    let restLine = item.line;
    let offset = 0;
    const indices = Array.from(
      restLine.matchAll(this.originFileBaseNameRegExp)
    ).map((x) => x.index);
    for (const index of indices) {
      const before = restLine.slice(0, index - offset);
      descriptionDiv.createSpan({
        text: trimLineByEllipsis(
          before,
          this.settings.maxDisplayLengthAroundMatchedWord
        )
      });
      descriptionDiv.createSpan({
        text: this.originFileBaseName,
        cls: "another-quick-switcher__hit_word"
      });
      offset = index - offset + this.originFileBaseName.length;
      restLine = restLine.slice(offset);
    }
    descriptionDiv.createSpan({
      text: trimLineByEllipsis(
        restLine,
        this.settings.maxDisplayLengthAroundMatchedWord
      )
    });
    if (item.order < 9) {
      const hotKeyGuide = createSpan({
        cls: "another-quick-switcher__backlink__item__hot-key-guide",
        text: `${item.order + 1}`
      });
      descriptionsDiv.appendChild(hotKeyGuide);
    }
    descriptionsDiv.appendChild(descriptionDiv);
    itemDiv.appendChild(descriptionsDiv);
    el.appendChild(itemDiv);
  }
  navigate(cb) {
    this.navQueue = this.navQueue.then(cb);
  }
  async chooseCurrentSuggestion(leaf, option = {}) {
    var _a, _b;
    const item = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem];
    if (!item) {
      return null;
    }
    if (!option.keepOpen) {
      this.close();
      this.navigate(() => this.isClosed);
    } else if (leaf === "same-tab") {
      (_b = this.stateToRestore) != null ? _b : this.stateToRestore = this.appHelper.captureState(this.initialLeaf);
    }
    this.navigate(
      () => this.appHelper.openFile(
        item.file,
        {
          leafType: leaf,
          line: item.lineNumber - 1,
          inplace: option.keepOpen,
          preventDuplicateTabs: this.settings.preventDuplicateTabs
        },
        this.stateToRestore
      )
    );
    return item.file;
  }
  async onChooseSuggestion() {
    await this.chooseCurrentSuggestion("same-tab");
  }
  registerKeys(key, handler) {
    const hotkeys = this.settings.hotkeys.backlink[key];
    for (const x of hotkeys) {
      this.scope.register(
        x.modifiers,
        normalizeKey(capitalizeFirstLetter(x.key)),
        (evt) => {
          if (!evt.isComposing) {
            evt.preventDefault();
            handler();
            return false;
          }
        }
      );
    }
  }
  setHotkeys() {
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Enter"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Escape"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Home"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "End"));
    const openNthMod = quickResultSelectionModifier(
      this.settings.userAltInsteadOfModForQuickResultSelection
    );
    if (!this.settings.hideHotkeyGuides) {
      this.setInstructions([
        { command: "[\u21B5]", purpose: "open" },
        { command: "[\u2191]", purpose: "up" },
        { command: "[\u2193]", purpose: "down" },
        { command: `[${openNthMod} 1~9]`, purpose: "open Nth" },
        ...createInstructions(this.settings.hotkeys.backlink)
      ]);
    }
    this.registerKeys("up", () => {
      document.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowUp" }));
    });
    this.registerKeys("down", () => {
      document.dispatchEvent(
        new KeyboardEvent("keydown", { key: "ArrowDown" })
      );
    });
    this.registerKeys("open", async () => {
      await this.chooseCurrentSuggestion("same-tab");
    });
    this.registerKeys("open in new tab", async () => {
      await this.chooseCurrentSuggestion("new-tab");
    });
    this.registerKeys("open in new pane (horizontal)", async () => {
      await this.chooseCurrentSuggestion("new-pane-horizontal");
    });
    this.registerKeys("open in new pane (vertical)", async () => {
      await this.chooseCurrentSuggestion("new-pane-vertical");
    });
    this.registerKeys("open in new window", async () => {
      await this.chooseCurrentSuggestion("new-window");
    });
    this.registerKeys("open in popup", async () => {
      await this.chooseCurrentSuggestion("popup");
    });
    this.registerKeys("open in new tab in background", async () => {
      await this.chooseCurrentSuggestion("new-tab-background", {
        keepOpen: true
      });
    });
    this.registerKeys("open all in new tabs", () => {
      this.close();
      if (this.chooser.values == null) {
        return;
      }
      const items = this.chooser.values.slice().reverse();
      for (const x of items) {
        this.appHelper.openFile(x.file, {
          leafType: "new-tab-background",
          preventDuplicateTabs: this.settings.preventDuplicateTabs
        });
      }
    });
    this.registerKeys("show all results", () => {
      this.limit = Number.MAX_SAFE_INTEGER;
      this.inputEl.dispatchEvent(new Event("input"));
    });
    this.registerKeys("preview", async () => {
      await this.chooseCurrentSuggestion("same-tab", {
        keepOpen: true
      });
    });
    const modifierKey = this.settings.userAltInsteadOfModForQuickResultSelection ? "Alt" : "Mod";
    for (const n of [1, 2, 3, 4, 5, 6, 7, 8, 9]) {
      this.scope.register([modifierKey], String(n), (evt) => {
        this.chooser.setSelectedItem(n - 1, evt);
        this.chooser.useSelectedItem({});
        return false;
      });
    }
    this.registerKeys("dismiss", async () => {
      this.close();
    });
  }
};

// src/ui/FolderModal.ts
var import_obsidian6 = require("obsidian");
function matchQuery2(item, query, matcher, isNormalizeAccentsDiacritics) {
  const qs = query.split("/");
  const folder = qs.pop();
  return qs.every(
    (dir) => {
      var _a;
      return smartIncludes(
        (_a = item.folder.parent) == null ? void 0 : _a.path,
        dir,
        isNormalizeAccentsDiacritics
      );
    }
  ) && matcher(item, folder);
}
function matchQueryAll2(item, queries, matcher, isNormalizeAccentsDiacritics) {
  return queries.every(
    (q) => matchQuery2(item, q, matcher, isNormalizeAccentsDiacritics)
  );
}
function stampMatchType(item, queries, isNormalizeAccentsDiacritics) {
  if (matchQueryAll2(
    item,
    queries,
    (item2, query) => smartStartsWith(item2.folder.name, query, isNormalizeAccentsDiacritics),
    isNormalizeAccentsDiacritics
  )) {
    return { ...item, matchType: "prefix-name" };
  }
  if (matchQueryAll2(
    item,
    queries,
    (item2, query) => smartIncludes(item2.folder.name, query, isNormalizeAccentsDiacritics),
    isNormalizeAccentsDiacritics
  )) {
    return { ...item, matchType: "name" };
  }
  if (matchQueryAll2(
    item,
    queries,
    (item2, query) => smartIncludes(item2.folder.path, query, isNormalizeAccentsDiacritics),
    isNormalizeAccentsDiacritics
  )) {
    return { ...item, matchType: "directory" };
  }
  return item;
}
var FolderModal = class extends import_obsidian6.SuggestModal {
  constructor(app, settings) {
    super(app);
    this.modalEl.addClass("another-quick-switcher__modal-prompt");
    this.appHelper = new AppHelper(app);
    this.settings = settings;
    this.setHotkeys();
    this.originItems = this.appHelper.getFolders().filter((x) => !x.isRoot()).map((x) => ({
      folder: x
    }));
    this.filteredItems = this.originItems;
  }
  getSuggestions(query) {
    const qs = query.split(" ").filter((x) => x);
    return this.filteredItems.map(
      (x) => stampMatchType(x, qs, this.settings.normalizeAccentsAndDiacritics)
    ).filter((x) => x.matchType).sort(sorter((x) => x.matchType === "directory" ? 1 : 0)).sort(
      sorter(
        (x) => x.matchType === "prefix-name" ? 1e3 - x.folder.name.length : 0,
        "desc"
      )
    ).slice(0, 10);
  }
  renderSuggestion(item, el) {
    var _a;
    const itemDiv = createDiv({
      cls: [
        "another-quick-switcher__item",
        "another-quick-switcher__directory_item"
      ]
    });
    const entryDiv = createDiv({
      cls: "another-quick-switcher__item__entry"
    });
    const folderDiv = createDiv({
      cls: "another-quick-switcher__item__title",
      text: item.folder.name
    });
    entryDiv.appendChild(folderDiv);
    const directoryDiv = createDiv({
      cls: "another-quick-switcher__item__directory"
    });
    directoryDiv.insertAdjacentHTML("beforeend", FOLDER);
    directoryDiv.appendText(` ${(_a = item.folder.parent) == null ? void 0 : _a.name}`);
    entryDiv.appendChild(directoryDiv);
    itemDiv.appendChild(entryDiv);
    el.appendChild(itemDiv);
  }
  async onChooseSuggestion(item) {
    if (!this.appHelper.enableFileExplorer()) {
      new import_obsidian6.Notice("File explorer (core plugin) is not enabled.");
      return;
    }
    this.appHelper.revealInFolder(item.folder);
  }
  registerKeys(key, handler) {
    var _a;
    for (const x of (_a = this.settings.hotkeys.folder[key]) != null ? _a : []) {
      this.scope.register(x.modifiers, x.key.toUpperCase(), (evt) => {
        evt.preventDefault();
        handler();
        return false;
      });
    }
  }
  setHotkeys() {
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Escape"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Home"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "End"));
    if (!this.settings.hideHotkeyGuides) {
      this.setInstructions([
        { command: "[\u21B5]", purpose: "reveal in file tree" },
        { command: "[\u2191]", purpose: "up" },
        { command: "[\u2193]", purpose: "down" },
        ...createInstructions(this.settings.hotkeys.folder)
      ]);
    }
    this.registerKeys("up", () => {
      document.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowUp" }));
    });
    this.registerKeys("down", () => {
      document.dispatchEvent(
        new KeyboardEvent("keydown", { key: "ArrowDown" })
      );
    });
    this.registerKeys("open in default app", () => {
      var _a, _b;
      const folder = (_b = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem]) == null ? void 0 : _b.folder;
      if (!folder) {
        return;
      }
      this.appHelper.openFolderInDefaultApp(folder);
      this.close();
    });
    this.registerKeys("dismiss", async () => {
      this.close();
    });
  }
};

// src/ui/GrepModal.ts
var import_obsidian7 = require("obsidian");

// src/utils/ripgrep.ts
var import_child_process = require("child_process");
async function existsRg(cmd) {
  return new Promise((resolve, _) => {
    (0, import_child_process.execFile)(cmd, ["--version"], (error, _stdout, _stderr) => {
      if (error) {
        console.dir(error);
      }
      resolve(!error);
    });
  });
}
async function rg(cmd, ...args) {
  return new Promise((resolve, _) => {
    (0, import_child_process.execFile)(
      cmd,
      ["--json", ...args],
      { maxBuffer: 100 * 1024 * 1024 },
      (_2, stdout, _stderr) => {
        const results = stdout.split("\n").filter((x) => x).map((x) => JSON.parse(x)).filter((x) => x.type === "match");
        resolve(results);
      }
    );
  });
}

// src/ui/GrepModal.ts
var globalInternalStorage2 = {
  items: [],
  basePath: void 0,
  selected: void 0
};
var GrepModal = class extends import_obsidian7.SuggestModal {
  constructor(app, settings, initialLeaf) {
    super(app);
    this.isClosed = new Promise((resolve) => {
      this.markClosed = resolve;
    });
    this.navQueue = Promise.resolve();
    this.modalEl.addClass("another-quick-switcher__modal-prompt");
    this.suggestions = globalInternalStorage2.items;
    this.vaultRootPath = normalizePath(
      this.app.vault.adapter.basePath
    );
    this.appHelper = new AppHelper(app);
    this.settings = settings;
    this.logger = Logger.of(this.settings);
    this.initialLeaf = initialLeaf;
    this.limit = 255;
    const searchCmd = this.settings.hotkeys.grep.search.at(0);
    if (searchCmd) {
      const inst = createInstruction("_", {
        key: searchCmd.key,
        modifiers: searchCmd.modifiers
      });
      this.setPlaceholder(`Search around the vault by ${inst == null ? void 0 : inst.command} key`);
    } else {
      this.setPlaceholder(
        `Please set a key about "search" in the "Grep dialog" setting`
      );
    }
    this.setHotkeys();
  }
  onOpen() {
    var _a;
    super.onOpen();
    setFloatingModal(this.appHelper);
    this.basePath = (_a = globalInternalStorage2.basePath) != null ? _a : "";
    window.setTimeout(() => {
      var _a2;
      const selected = globalInternalStorage2.selected;
      if (selected != null) {
        this.chooser.setSelectedItem(selected);
        (_a2 = this.chooser.suggestions.at(selected)) == null ? void 0 : _a2.scrollIntoView({
          behavior: "auto",
          block: "center",
          inline: "center"
        });
      }
      this.basePathInputEl = createEl("input", {
        value: this.basePath,
        placeholder: "path from vault root (./ means current directory. ../ means parent directory)",
        cls: "another-quick-switcher__grep__path-input",
        type: "text"
      });
      this.basePathInputEl.setAttrs({
        autocomplete: "on",
        list: "directories"
      });
      const basePathInputList = createEl("datalist");
      basePathInputList.setAttrs({ id: "directories" });
      const folders = this.appHelper.getFolders().filter((x) => !x.isRoot());
      for (const x of folders) {
        basePathInputList.appendChild(createEl("option", { value: x.path }));
      }
      this.basePathInputElChangeEventListener = (evt) => {
        this.basePath = evt.target.value;
      };
      this.basePathInputElKeydownEventListener = (evt) => {
        if (!evt.key) {
          evt.preventDefault();
          return;
        }
        const hotkey = this.settings.hotkeys.grep.search[0];
        if (!hotkey) {
          return;
        }
        const keyEvent = evt;
        if (equalsAsHotkey(hotkey, keyEvent)) {
          evt.preventDefault();
          this.basePath = evt.target.value;
          this.currentQuery = this.clonedInputEl.value;
          this.inputEl.value = this.currentQuery;
          this.inputEl.dispatchEvent(new Event("input"));
        }
      };
      this.basePathInputEl.addEventListener(
        "change",
        this.basePathInputElChangeEventListener
      );
      this.basePathInputEl.addEventListener(
        "keydown",
        this.basePathInputElKeydownEventListener
      );
      const wrapper = createDiv({
        cls: "another-quick-switcher__grep__path-input__wrapper"
      });
      wrapper.appendChild(this.basePathInputEl);
      wrapper.appendChild(basePathInputList);
      const promptInputContainerEl = activeWindow.activeDocument.querySelector(
        ".prompt-input-container"
      );
      promptInputContainerEl == null ? void 0 : promptInputContainerEl.after(wrapper);
      wrapper.insertAdjacentHTML("afterbegin", FOLDER);
    }, 0);
  }
  onClose() {
    super.onClose();
    globalInternalStorage2.items = this.suggestions;
    globalInternalStorage2.basePath = this.basePath;
    globalInternalStorage2.selected = this.chooser.selectedItem;
    this.clonedInputEl.removeEventListener(
      "keydown",
      this.clonedInputElKeydownEventListener
    );
    this.basePathInputEl.removeEventListener(
      "change",
      this.basePathInputElChangeEventListener
    );
    this.basePathInputEl.removeEventListener(
      "keydown",
      this.basePathInputElKeydownEventListener
    );
    if (this.stateToRestore) {
      this.navigate(() => this.stateToRestore.restore());
    }
    this.navigate(this.markClosed);
  }
  async searchSuggestions(query) {
    var _a;
    const start = performance.now();
    (_a = this.countInputEl) == null ? void 0 : _a.remove();
    this.countInputEl = createDiv({
      text: "searching...",
      cls: "another-quick-switcher__grep__count-input"
    });
    this.clonedInputEl.before(this.countInputEl);
    const absolutePathFromRoot = normalizeRelativePath(
      this.basePath,
      this.appHelper.getCurrentDirPath()
    );
    const rgResults = await rg(
      this.settings.ripgrepCommand,
      ...[
        ...this.settings.grepExtensions.flatMap((x) => ["-t", x]),
        hasCapitalLetter(query) ? "" : "-i",
        "--",
        query,
        `${this.vaultRootPath}/${absolutePathFromRoot}`
      ].filter((x) => x)
    );
    const items = rgResults.map((x) => {
      return {
        order: -1,
        file: this.appHelper.getFileByPath(
          normalizePath(x.data.path.text).replace(
            `${this.vaultRootPath}/`,
            ""
          )
        ),
        line: x.data.lines.text,
        lineNumber: x.data.line_number,
        offset: x.data.absolute_offset,
        submatches: x.data.submatches
      };
    }).filter((x) => x.file != null).sort(sorter((x) => x.file.stat.mtime, "desc")).map((x, order) => ({ ...x, order }));
    this.logger.showDebugLog("getSuggestions: ", start);
    return items;
  }
  async getSuggestions(query) {
    var _a;
    if (query) {
      this.suggestions = await this.searchSuggestions(query);
      (_a = this.countInputEl) == null ? void 0 : _a.remove();
      this.countInputEl = createDiv({
        text: `${Math.min(this.suggestions.length, this.limit)} / ${this.suggestions.length}`,
        cls: "another-quick-switcher__grep__count-input"
      });
      this.clonedInputEl.before(this.countInputEl);
    }
    return this.suggestions;
  }
  renderSuggestion(item, el) {
    var _a, _b, _c;
    const previousPath = (_a = this.suggestions[item.order - 1]) == null ? void 0 : _a.file.path;
    const sameFileWithPrevious = previousPath === item.file.path;
    const itemDiv = createDiv({
      cls: "another-quick-switcher__item"
    });
    const entryDiv = createDiv({
      cls: "another-quick-switcher__item__entry"
    });
    if (!sameFileWithPrevious) {
      const titleDiv = createDiv({
        cls: [
          "another-quick-switcher__item__title",
          "another-quick-switcher__grep__item__title_entry"
        ],
        text: item.file.basename,
        attr: {
          extension: item.file.extension
        }
      });
      const isExcalidrawFile = isExcalidraw(item.file);
      if (item.file.extension !== "md" || isExcalidrawFile) {
        const extDiv = createDiv({
          cls: "another-quick-switcher__item__extension",
          text: isExcalidrawFile ? "excalidraw" : item.file.extension
        });
        titleDiv.appendChild(extDiv);
      }
      entryDiv.appendChild(titleDiv);
      itemDiv.appendChild(entryDiv);
      if (this.settings.showDirectory) {
        const directoryDiv = createDiv({
          cls: "another-quick-switcher__item__directory"
        });
        directoryDiv.insertAdjacentHTML("beforeend", FOLDER);
        const text = this.settings.showFullPathOfDirectory ? (_b = item.file.parent) == null ? void 0 : _b.path : (_c = item.file.parent) == null ? void 0 : _c.name;
        directoryDiv.appendText(` ${text}`);
        entryDiv.appendChild(directoryDiv);
        if (this.settings.showDirectoryAtNewLine) {
          itemDiv.appendChild(directoryDiv);
        }
      }
    }
    const descriptionsDiv = createDiv({
      cls: "another-quick-switcher__item__descriptions"
    });
    const descriptionDiv = createDiv({
      cls: "another-quick-switcher__grep__item__description"
    });
    let restLine = item.line;
    for (const x of item.submatches) {
      const i = restLine.indexOf(x.match.text);
      const before = restLine.slice(0, i);
      descriptionDiv.createSpan({
        text: trimLineByEllipsis(
          before,
          this.settings.maxDisplayLengthAroundMatchedWord
        )
      });
      descriptionDiv.createSpan({
        text: x.match.text,
        cls: "another-quick-switcher__hit_word"
      });
      restLine = restLine.slice(i + x.match.text.length);
    }
    descriptionDiv.createSpan({
      text: trimLineByEllipsis(
        restLine,
        this.settings.maxDisplayLengthAroundMatchedWord
      )
    });
    if (item.order < 9) {
      const hotKeyGuide = createSpan({
        cls: "another-quick-switcher__grep__item__hot-key-guide",
        text: `${item.order + 1}`
      });
      descriptionsDiv.appendChild(hotKeyGuide);
    }
    descriptionsDiv.appendChild(descriptionDiv);
    itemDiv.appendChild(descriptionsDiv);
    el.appendChild(itemDiv);
  }
  navigate(cb) {
    this.navQueue = this.navQueue.then(cb);
  }
  async chooseCurrentSuggestion(leaf, option = {}) {
    var _a, _b;
    const item = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem];
    if (!item) {
      return null;
    }
    if (!option.keepOpen) {
      this.close();
      this.navigate(() => this.isClosed);
    } else if (leaf === "same-tab") {
      (_b = this.stateToRestore) != null ? _b : this.stateToRestore = this.appHelper.captureState(this.initialLeaf);
    }
    this.navigate(
      () => this.appHelper.openFile(
        item.file,
        {
          leafType: leaf,
          line: item.lineNumber - 1,
          inplace: option.keepOpen,
          preventDuplicateTabs: this.settings.preventDuplicateTabs
        },
        this.stateToRestore
      )
    );
    return item.file;
  }
  async onChooseSuggestion() {
    await this.chooseCurrentSuggestion("same-tab");
  }
  registerKeys(key, handler) {
    const hotkeys = this.settings.hotkeys.grep[key];
    for (const x of hotkeys) {
      this.scope.register(
        x.modifiers,
        normalizeKey(capitalizeFirstLetter(x.key)),
        (evt) => {
          if (!evt.isComposing) {
            evt.preventDefault();
            handler();
            return false;
          }
        }
      );
    }
  }
  setHotkeys() {
    var _a;
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Enter"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Escape"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Home"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "End"));
    const openNthMod = quickResultSelectionModifier(
      this.settings.userAltInsteadOfModForQuickResultSelection
    );
    if (!this.settings.hideHotkeyGuides) {
      this.setInstructions([
        { command: "[\u21B5]", purpose: "open" },
        { command: "[\u2191]", purpose: "up" },
        { command: "[\u2193]", purpose: "down" },
        { command: `[${openNthMod} 1~9]`, purpose: "open Nth" },
        ...createInstructions(this.settings.hotkeys.grep)
      ]);
    }
    this.clonedInputEl = this.inputEl.cloneNode(true);
    (_a = this.inputEl.parentNode) == null ? void 0 : _a.replaceChild(this.clonedInputEl, this.inputEl);
    this.clonedInputElKeydownEventListener = (evt) => {
      const keyEvent = evt;
      const hotkey = this.settings.hotkeys.grep.search[0];
      if (!hotkey) {
        return;
      }
      if (equalsAsHotkey(hotkey, keyEvent)) {
        evt.preventDefault();
        this.currentQuery = this.clonedInputEl.value;
        this.inputEl.value = this.currentQuery;
        this.inputEl.dispatchEvent(new Event("input"));
      }
    };
    this.clonedInputEl.addEventListener(
      "keydown",
      this.clonedInputElKeydownEventListener
    );
    this.registerKeys("up", () => {
      document.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowUp" }));
    });
    this.registerKeys("down", () => {
      document.dispatchEvent(
        new KeyboardEvent("keydown", { key: "ArrowDown" })
      );
    });
    this.registerKeys("clear input", () => {
      this.clonedInputEl.value = "";
      this.clonedInputEl.dispatchEvent(new InputEvent("input"));
      this.clonedInputEl.focus();
    });
    this.registerKeys("clear path", () => {
      this.basePathInputEl.value = "";
      this.basePathInputEl.dispatchEvent(new InputEvent("change"));
    });
    this.registerKeys("set ./ to path", () => {
      this.basePathInputEl.value = "./";
      this.basePathInputEl.dispatchEvent(new InputEvent("change"));
    });
    this.registerKeys("open", async () => {
      await this.chooseCurrentSuggestion("same-tab");
    });
    this.registerKeys("open in new tab", async () => {
      await this.chooseCurrentSuggestion("new-tab");
    });
    this.registerKeys("open in new pane (horizontal)", async () => {
      await this.chooseCurrentSuggestion("new-pane-horizontal");
    });
    this.registerKeys("open in new pane (vertical)", async () => {
      await this.chooseCurrentSuggestion("new-pane-vertical");
    });
    this.registerKeys("open in new window", async () => {
      await this.chooseCurrentSuggestion("new-window");
    });
    this.registerKeys("open in popup", async () => {
      await this.chooseCurrentSuggestion("popup");
    });
    this.registerKeys("open in new tab in background", async () => {
      await this.chooseCurrentSuggestion("new-tab-background", {
        keepOpen: true
      });
    });
    this.registerKeys("open all in new tabs", () => {
      this.close();
      if (this.chooser.values == null) {
        return;
      }
      const items = this.chooser.values.slice().reverse();
      for (const x of items) {
        this.appHelper.openFile(x.file, {
          leafType: "new-tab-background",
          preventDuplicateTabs: this.settings.preventDuplicateTabs
        });
      }
    });
    this.registerKeys("preview", async () => {
      await this.chooseCurrentSuggestion("same-tab", {
        keepOpen: true
      });
    });
    const modifierKey = this.settings.userAltInsteadOfModForQuickResultSelection ? "Alt" : "Mod";
    for (const n of [1, 2, 3, 4, 5, 6, 7, 8, 9]) {
      this.scope.register([modifierKey], String(n), (evt) => {
        this.chooser.setSelectedItem(n - 1, evt);
        this.chooser.useSelectedItem({});
        return false;
      });
    }
    this.registerKeys("dismiss", async () => {
      this.close();
    });
  }
};

// src/ui/HeaderModal.ts
var import_obsidian8 = require("obsidian");
var HeaderModal = class extends import_obsidian8.SuggestModal {
  constructor(app, settings, floating) {
    super(app);
    this.hitItems = [];
    /** !Not work correctly in all cases */
    this.unsafeSelectedIndex = 0;
    this.modalEl.addClass("another-quick-switcher__modal-prompt");
    this.limit = 1e3;
    this.appHelper = new AppHelper(app);
    this.settings = settings;
    this.floating = floating;
    this.autoPreview = settings.autoPreviewInFloatingHeaderSearch && floating;
    this.items = this.appHelper.getHeadersInActiveFile().map((x, i) => ({
      value: excludeFormat(x.heading),
      level: x.level,
      position: x.position,
      hit: false,
      index: i
    }));
    this.inputEl.addEventListener("input", (evt) => {
      var _a, _b;
      const unsafeEvt = evt;
      if (this.hitItems.length === 0) {
        this.select(this.unsafeSelectedIndex, unsafeEvt);
        return;
      }
      const nextIndex = (_b = (_a = this.hitItems.find((x) => x.index >= this.unsafeSelectedIndex)) == null ? void 0 : _a.index) != null ? _b : this.hitItems[0].index;
      this.select(nextIndex, unsafeEvt);
    });
    this.setHotkeys();
  }
  select(index, evt, suppressAutoPreview) {
    var _a;
    this.chooser.setSelectedItem(index, evt);
    (_a = this.chooser.suggestions.at(index)) == null ? void 0 : _a.scrollIntoView({
      behavior: "auto",
      block: "center",
      inline: "center"
    });
    this.unsafeSelectedIndex = index;
    const item = this.items.at(this.unsafeSelectedIndex);
    if (this.autoPreview && item && !suppressAutoPreview) {
      this.appHelper.moveTo(item.position);
    }
  }
  getNextSelectIndex() {
    return this.unsafeSelectedIndex + 1 > this.items.length - 1 ? 0 : this.unsafeSelectedIndex + 1;
  }
  getPreviousSelectIndex() {
    return this.unsafeSelectedIndex - 1 < 0 ? this.items.length - 1 : this.unsafeSelectedIndex - 1;
  }
  onOpen() {
    super.onOpen();
    if (this.floating) {
      this.enableFloating();
      this.refreshPreviewIcon();
    }
    const markdownView = this.appHelper.getMarkdownViewInActiveLeaf();
    if (!markdownView || this.items.length === 0) {
      return;
    }
    const mode = markdownView.getMode();
    const offset = mode === "source" ? this.appHelper.getCurrentOffset() : markdownView.editor.posToOffset({
      ch: 0,
      line: markdownView.previewMode.getScroll()
    });
    if (!offset) {
      return;
    }
    const firstOverIndex = this.items.findIndex(
      (x) => x.position.start.offset > offset
    );
    if (firstOverIndex === -1) {
      this.select(this.items.last().index, void 0, true);
    } else if (firstOverIndex === 0) {
      this.select(0, void 0, true);
    } else {
      this.select(firstOverIndex - 1, void 0, true);
    }
  }
  refreshPreviewIcon() {
    var _a, _b;
    (_a = this.previewIcon) == null ? void 0 : _a.remove();
    if (this.autoPreview) {
      this.previewIcon = this.inputEl.insertAdjacentElement(
        "afterend",
        createDiv({ cls: "another-quick-switcher__header__auto-preview-icon" })
      );
      (_b = this.previewIcon) == null ? void 0 : _b.insertAdjacentHTML("beforeend", PREVIEW);
    }
  }
  enableFloating() {
    this.floating = true;
    if (!import_obsidian8.Platform.isPhone) {
      setFloatingModal(this.appHelper);
    }
  }
  getSuggestions(query) {
    const qs = smartWhitespaceSplit(query);
    const suggestions = this.items.map((x) => {
      const hit = qs.length > 0 && qs.every(
        (q) => smartIncludes(
          x.value,
          q,
          this.settings.normalizeAccentsAndDiacritics
        )
      );
      return { ...x, hit };
    });
    this.hitItems = suggestions.filter((x) => x.hit);
    return suggestions;
  }
  renderSuggestion(item, el) {
    const itemDiv = createDiv({
      cls: "another-quick-switcher__item"
    });
    const entryDiv = createDiv({
      cls: "another-quick-switcher__item__entry"
    });
    const headerDiv = createDiv({
      cls: [
        "another-quick-switcher__item__title",
        "another-quick-switcher__item__title__header",
        item.hit ? "another-quick-switcher__item__title__header_hit" : "another-quick-switcher__item__title__header_no_hit",
        `another-quick-switcher__item__title__header${item.level}`
      ],
      text: item.value
    });
    entryDiv.appendChild(headerDiv);
    if (item.hit) {
      const i = this.hitItems.findIndex((x) => x.index === item.index);
      if (i !== -1) {
        entryDiv.createSpan({
          cls: "another-quick-switcher__item__title__header_hit__counter",
          text: `${i + 1} / ${this.hitItems.length}`
        });
      }
    }
    itemDiv.appendChild(entryDiv);
    el.appendChild(itemDiv);
  }
  async onChooseSuggestion(item) {
    this.appHelper.moveTo(item.position);
  }
  registerKeys(key, handler) {
    var _a;
    for (const x of (_a = this.settings.hotkeys.header[key]) != null ? _a : []) {
      this.scope.register(
        x.modifiers,
        normalizeKey(capitalizeFirstLetter(x.key)),
        (evt) => {
          if (!evt.isComposing) {
            evt.preventDefault();
            handler(evt);
            return false;
          }
        }
      );
    }
  }
  setHotkeys() {
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Escape"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Home"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "End"));
    if (!this.settings.hideHotkeyGuides) {
      this.setInstructions([
        { command: "[\u21B5]", purpose: "move to header" },
        { command: "[\u2191]", purpose: "up" },
        { command: "[\u2193]", purpose: "down" },
        ...createInstructions(this.settings.hotkeys.header)
      ]);
    }
    const navigateNext = (evt) => {
      this.select(this.getNextSelectIndex(), evt);
    };
    const navigatePrevious = (evt) => {
      this.select(this.getPreviousSelectIndex(), evt);
    };
    const moveToNextHit = (evt) => {
      var _a, _b;
      if (this.hitItems.length === 1) {
        return;
      }
      if (this.hitItems.length === 0) {
        navigateNext(evt);
        return;
      }
      const nextIndex = (_b = (_a = this.hitItems.find((x) => x.index > this.unsafeSelectedIndex)) == null ? void 0 : _a.index) != null ? _b : this.hitItems[0].index;
      this.select(nextIndex, evt);
    };
    const moveToPreviousHit = (evt) => {
      if (this.hitItems.length === 1) {
        return;
      }
      if (this.hitItems.length === 0) {
        navigatePrevious(evt);
        return;
      }
      const currentIndex = this.hitItems.findIndex(
        (x) => x.index >= this.unsafeSelectedIndex
      );
      const previousIndex = currentIndex === 0 ? this.hitItems.length - 1 : currentIndex - 1;
      this.select(this.hitItems[previousIndex].index, evt);
    };
    for (const x of this.scope.keys.filter(
      (x2) => ["ArrowDown", "ArrowUp"].includes(x2.key)
    )) {
      this.scope.unregister(x);
    }
    this.scope.register([], "ArrowUp", (evt) => {
      evt.preventDefault();
      navigatePrevious(evt);
      return false;
    });
    this.scope.register([], "ArrowDown", (evt) => {
      evt.preventDefault();
      navigateNext(evt);
      return false;
    });
    this.registerKeys("up", (evt) => {
      navigatePrevious(evt);
    });
    this.registerKeys("down", (evt) => {
      navigateNext(evt);
    });
    this.registerKeys("clear input", () => {
      this.inputEl.value = "";
      this.inputEl.dispatchEvent(new InputEvent("input"));
    });
    this.registerKeys("move to next hit", (evt) => {
      moveToNextHit(evt);
    });
    this.registerKeys("move to previous hit", (evt) => {
      moveToPreviousHit(evt);
    });
    this.registerKeys("toggle auto preview", () => {
      this.autoPreview = !this.autoPreview;
      this.refreshPreviewIcon();
      if (this.autoPreview && !this.floating) {
        this.enableFloating();
      }
    });
    this.registerKeys("insert all to editor", async () => {
      this.close();
      const headers = this.chooser.values;
      if (!headers) {
        return;
      }
      const minLevel = minBy(headers, (x) => x.level).level;
      for (const x of headers) {
        this.appHelper.insertStringToActiveFile(
          `${" ".repeat((x.level - minLevel) * 4)}- ${x.value}
`
        );
      }
    });
    this.registerKeys("dismiss", async () => {
      this.close();
    });
  }
};

// src/ui/InFileModal.ts
var import_obsidian9 = require("obsidian");
var globalInternalStorage3 = {
  query: "",
  selected: null
};
var InFileModal = class extends import_obsidian9.SuggestModal {
  constructor(app, settings, initialLeaf) {
    super(app);
    /** !Not work correctly in all cases */
    this.unsafeSelectedIndex = 0;
    this.suggestions = [];
    this.modalEl.addClass("another-quick-switcher__modal-prompt");
    this.appHelper = new AppHelper(app);
    this.settings = settings;
    this.logger = Logger.of(this.settings);
    this.initialLeaf = initialLeaf;
    this.floating = this.settings.autoPreviewInFloatingInFileSearch;
    this.autoPreview = settings.autoPreviewInFloatingInFileSearch;
    this.limit = 255;
    this.setHotkeys();
    this.setPlaceholder("Type anything then shows the results");
  }
  close() {
    if (import_obsidian9.Platform.isMobile) {
      this.onClose();
    }
    super.close();
  }
  async init() {
    await this.indexingItems();
  }
  onOpen() {
    var _a;
    this.isOpen = true;
    this.inputEl.value = globalInternalStorage3.query;
    this.inputEl.select();
    this.updateSuggestions();
    if (this.floating) {
      this.enableFloating();
      this.refreshPreviewIcon();
    }
    if (globalInternalStorage3.selected != null && this.chooser.suggestions.length > 0) {
      const selected = Math.min(
        globalInternalStorage3.selected,
        this.chooser.suggestions.length - 1
      );
      this.select(selected);
      (_a = this.chooser.suggestions.at(selected)) == null ? void 0 : _a.scrollIntoView({
        behavior: "auto",
        block: "center",
        inline: "center"
      });
    }
    this.inputEl.addEventListener("input", (evt) => {
      const unsafeEvt = evt;
      if (this.suggestions.length === 0) {
        return;
      }
      this.select(
        Math.min(this.unsafeSelectedIndex, this.suggestions.length - 1),
        unsafeEvt
      );
    });
    this.opened = true;
  }
  onClose() {
    super.onClose();
    globalInternalStorage3.query = this.inputEl.value;
    globalInternalStorage3.selected = this.chooser.values != null ? this.chooser.selectedItem : null;
  }
  select(index, evt) {
    this.chooser.setSelectedItem(index, evt);
    this.unsafeSelectedIndex = index;
    if (this.autoPreview) {
      const p = {
        line: this.chooser.values[index].lineNumber - 1,
        offset: 0,
        col: 0
      };
      this.appHelper.moveTo({
        start: p,
        end: p
      });
    }
  }
  getNextSelectIndex() {
    return this.chooser.selectedItem + 1 > this.chooser.suggestions.length - 1 ? 0 : this.chooser.selectedItem + 1;
  }
  getPreviousSelectIndex() {
    return this.chooser.selectedItem - 1 < 0 ? this.chooser.suggestions.length - 1 : this.chooser.selectedItem - 1;
  }
  refreshPreviewIcon() {
    var _a, _b;
    (_a = this.previewIcon) == null ? void 0 : _a.remove();
    if (this.autoPreview) {
      this.previewIcon = this.inputEl.insertAdjacentElement(
        "afterend",
        createDiv({
          cls: "another-quick-switcher__in-file__auto-preview-icon"
        })
      );
      (_b = this.previewIcon) == null ? void 0 : _b.insertAdjacentHTML("beforeend", PREVIEW);
    }
  }
  enableFloating() {
    this.floating = true;
    if (!import_obsidian9.Platform.isPhone) {
      setFloatingModal(this.appHelper);
    }
  }
  async indexingItems() {
    const lines = this.appHelper.getCurrentEditor().getValue().split("\n");
    this.ignoredItems = lines.map((line, i) => ({
      lineBefore: range(this.settings.inFileContextLines).reverse().map((x) => lines[i - x - 1]).filter(isPresent),
      line,
      lineAfter: range(this.settings.inFileContextLines).map((x) => lines[i + x + 1]).filter(isPresent),
      lineNumber: i + 1
    }));
  }
  getSuggestions(query) {
    var _a;
    const start = performance.now();
    const isQueryEmpty = query.trim() === "";
    const queries = query.trim().split(" ");
    this.currentQueriesRegExp = new RegExp(
      queries.map(escapeRegExp).join("|"),
      "gi"
    );
    const matchedSuggestions = isQueryEmpty ? [] : this.ignoredItems.filter(
      (x) => queries.every(
        (q) => capitalIncludes(
          x.line,
          q,
          this.settings.normalizeAccentsAndDiacritics
        )
      )
    );
    this.logger.showDebugLog(`Get suggestions: ${query}`, start);
    (_a = this.countInputEl) == null ? void 0 : _a.remove();
    this.countInputEl = createDiv({
      text: `${Math.min(matchedSuggestions.length, this.limit)} / ${matchedSuggestions.length}`,
      cls: "another-quick-switcher__in-file__status__count-input"
    });
    this.inputEl.before(this.countInputEl);
    this.suggestions = matchedSuggestions.slice(0, this.limit).map((x, order) => ({ ...x, order }));
    return this.suggestions;
  }
  renderSuggestion(item, el) {
    const itemDiv = createDiv({
      cls: [
        "another-quick-switcher__item",
        "another-quick-switcher__in-file__item"
      ]
    });
    const descriptionsDiv = createDiv({
      cls: "another-quick-switcher__item__descriptions"
    });
    const descriptionDiv = createDiv({
      cls: "another-quick-switcher__in-file__item__description"
    });
    item.lineBefore.forEach((line, i) => {
      const lineDiv = descriptionDiv.createDiv({
        cls: "another-quick-switcher__in-file__line"
      });
      lineDiv.createSpan({
        text: String(item.lineNumber - item.lineBefore.length + i),
        cls: "another-quick-switcher__in-file__line-number"
      });
      lineDiv.createSpan({
        text: trimLineByEllipsis(
          line,
          this.settings.inFileMaxDisplayLengthAroundMatchedWord
        )
      });
    });
    const activeLineDiv = descriptionDiv.createDiv({
      cls: [
        "another-quick-switcher__in-file__line",
        "another-quick-switcher__in-file__active-line"
      ]
    });
    activeLineDiv.createSpan({
      text: item.lineNumber.toString(),
      cls: "another-quick-switcher__in-file__line-number"
    });
    const activeLineBlockDiv = activeLineDiv.createDiv();
    let restLine = item.line;
    let offset = 0;
    const indexAndText = Array.from(
      restLine.matchAll(this.currentQueriesRegExp)
    ).map((x) => ({ index: x.index, text: x[0] }));
    for (const { index, text } of indexAndText) {
      const before = restLine.slice(0, index - offset);
      activeLineBlockDiv.createSpan({
        text: trimLineByEllipsis(
          before,
          this.settings.inFileMaxDisplayLengthAroundMatchedWord
        )
      });
      activeLineBlockDiv.createSpan({
        text,
        cls: "another-quick-switcher__hit_word"
      });
      offset += before.length + text.length;
      restLine = item.line.slice(offset);
    }
    activeLineBlockDiv.createSpan({
      text: trimLineByEllipsis(
        restLine,
        this.settings.inFileMaxDisplayLengthAroundMatchedWord
      )
    });
    item.lineAfter.forEach((line, i) => {
      const lineDiv = descriptionDiv.createDiv({
        cls: "another-quick-switcher__in-file__line"
      });
      lineDiv.createSpan({
        text: String(item.lineNumber + i + 1),
        cls: "another-quick-switcher__in-file__line-number"
      });
      lineDiv.createSpan({
        text: trimLineByEllipsis(
          line,
          this.settings.inFileMaxDisplayLengthAroundMatchedWord
        )
      });
    });
    if (item.order < 9) {
      const hotKeyGuide = createSpan({
        cls: "another-quick-switcher__in-file__item__hot-key-guide",
        text: `${item.order + 1}`
      });
      descriptionsDiv.appendChild(hotKeyGuide);
    }
    descriptionsDiv.appendChild(descriptionDiv);
    itemDiv.appendChild(descriptionsDiv);
    el.appendChild(itemDiv);
  }
  async onChooseSuggestion(item) {
    this.appHelper.moveTo(
      this.appHelper.getCurrentEditor().posToOffset({ line: item.lineNumber - 1, ch: 0 })
    );
  }
  registerKeys(key, handler) {
    var _a;
    for (const x of (_a = this.settings.hotkeys["in-file"][key]) != null ? _a : []) {
      this.scope.register(
        x.modifiers,
        normalizeKey(capitalizeFirstLetter(x.key)),
        (evt) => {
          if (!evt.isComposing) {
            evt.preventDefault();
            handler(evt);
            return false;
          }
        }
      );
    }
  }
  setHotkeys() {
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Escape"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Home"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "End"));
    const openNthMod = quickResultSelectionModifier(
      this.settings.userAltInsteadOfModForQuickResultSelection
    );
    if (!this.settings.hideHotkeyGuides) {
      this.setInstructions([
        { command: "[\u21B5]", purpose: "open" },
        { command: "[\u2191]", purpose: "up" },
        { command: "[\u2193]", purpose: "down" },
        { command: `[${openNthMod} 1~9]`, purpose: "open Nth" },
        ...createInstructions(this.settings.hotkeys["in-file"])
      ]);
    }
    const navigateNext = (evt) => {
      this.select(this.getNextSelectIndex(), evt);
    };
    const navigatePrevious = (evt) => {
      this.select(this.getPreviousSelectIndex(), evt);
    };
    const keyHandlers = this.scope.keys.filter(
      (x) => ["ArrowDown", "ArrowUp"].includes(x.key)
    );
    for (const x of keyHandlers) {
      this.scope.unregister(x);
    }
    this.scope.register([], "ArrowUp", (evt) => {
      evt.preventDefault();
      navigatePrevious(evt);
      return false;
    });
    this.scope.register([], "ArrowDown", (evt) => {
      evt.preventDefault();
      navigateNext(evt);
      return false;
    });
    this.registerKeys("up", (evt) => {
      navigatePrevious(evt);
    });
    this.registerKeys("down", (evt) => {
      navigateNext(evt);
    });
    this.registerKeys("show all results", () => {
      this.limit = Number.MAX_SAFE_INTEGER;
      this.inputEl.dispatchEvent(new Event("input"));
    });
    const modifierKey = this.settings.userAltInsteadOfModForQuickResultSelection ? "Alt" : "Mod";
    for (const n of [1, 2, 3, 4, 5, 6, 7, 8, 9]) {
      this.scope.register([modifierKey], String(n), (evt) => {
        this.chooser.setSelectedItem(n - 1, evt);
        this.chooser.useSelectedItem({});
        return false;
      });
    }
    this.registerKeys("toggle auto preview", () => {
      this.autoPreview = !this.autoPreview;
      this.refreshPreviewIcon();
      if (this.autoPreview) {
        this.select(this.unsafeSelectedIndex);
        if (!this.floating) {
          this.enableFloating();
        }
      }
    });
    this.registerKeys("dismiss", async () => {
      this.close();
    });
  }
};

// src/ui/LinkModal.ts
var import_obsidian10 = require("obsidian");
var LinkModal = class extends import_obsidian10.SuggestModal {
  constructor(app, settings, initialLeaf) {
    super(app);
    this.lastOpenFileIndexByPath = {};
    this.suggestions = [];
    this.isClosed = new Promise((resolve) => {
      this.markClosed = resolve;
    });
    this.navQueue = Promise.resolve();
    this.modalEl.addClass("another-quick-switcher__modal-prompt");
    this.vaultRootPath = normalizePath(
      this.app.vault.adapter.basePath
    );
    this.appHelper = new AppHelper(app);
    this.settings = settings;
    this.logger = Logger.of(this.settings);
    this.initialLeaf = initialLeaf;
    this.limit = 255;
    this.app.workspace.getLastOpenFiles().forEach((v, i) => {
      this.lastOpenFileIndexByPath[v] = i;
    });
    this.setHotkeys();
    this.debounceGetSuggestions = (0, import_obsidian10.debounce)(
      (query, cb) => {
        cb(this._getSuggestions(query));
      },
      this.settings.searchDelayMilliSeconds,
      true
    );
  }
  async init() {
    await this.indexingItems();
  }
  onOpen() {
    super.onOpen();
    if (!import_obsidian10.Platform.isPhone) {
      setFloatingModal(this.appHelper);
    }
    this.opened = true;
  }
  onClose() {
    super.onClose();
    if (this.stateToRestore) {
      this.navigate(() => this.stateToRestore.restore());
    }
    this.navigate(this.markClosed);
  }
  async indexingItems() {
    const ignoredItems = [];
    const links = this.appHelper.getLinksByFilePathInActiveFile();
    if (!links) {
      return;
    }
    for (const [path, caches] of Object.entries(links)) {
      const file = this.appHelper.getFileByPath(path);
      const content = this.appHelper.getCurrentEditor().getValue();
      for (const cache of caches) {
        if (!isFrontMatterLinkCache(cache)) {
          ignoredItems.push({
            file,
            displayLink: cache.displayText,
            line: content.split("\n").at(cache.position.start.line),
            lineNumber: cache.position.start.line + 1,
            offset: cache.position.start.offset
          });
        }
      }
    }
    this.ignoredItems = ignoredItems;
  }
  getSuggestions(query) {
    if (!query || !this.opened) {
      return this._getSuggestions(query);
    }
    return new Promise((resolve) => {
      this.debounceGetSuggestions(query, (items) => {
        resolve(items);
      });
    });
  }
  _getSuggestions(query) {
    var _a;
    const start = performance.now();
    const isQueryEmpty = query.trim() === "";
    const queries = query.trim().split(" ");
    const matchedSuggestions = isQueryEmpty ? this.ignoredItems : this.ignoredItems.filter(
      (x) => queries.every(
        (q) => x.file && smartIncludes(
          x.file.path,
          q,
          this.settings.normalizeAccentsAndDiacritics
        ) || smartIncludes(
          x.line,
          q,
          this.settings.normalizeAccentsAndDiacritics
        )
      )
    );
    this.logger.showDebugLog(`Get suggestions: ${query}`, start);
    (_a = this.countInputEl) == null ? void 0 : _a.remove();
    this.countInputEl = createDiv({
      text: `${Math.min(matchedSuggestions.length, this.limit)} / ${matchedSuggestions.length}`,
      cls: "another-quick-switcher__link__status__count-input"
    });
    this.inputEl.before(this.countInputEl);
    this.suggestions = matchedSuggestions.slice(0, this.limit).map((x, order) => ({ ...x, order }));
    return this.suggestions;
  }
  renderSuggestion(item, el) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const previousPath = (_d = (_b = (_a = this.suggestions[item.order - 1]) == null ? void 0 : _a.file) == null ? void 0 : _b.path) != null ? _d : (_c = this.suggestions[item.order - 1]) == null ? void 0 : _c.displayLink;
    const sameFileWithPrevious = previousPath === ((_f = (_e = item.file) == null ? void 0 : _e.path) != null ? _f : item.displayLink);
    const itemDiv = createDiv({
      cls: "another-quick-switcher__item"
    });
    const entryDiv = createDiv({
      cls: "another-quick-switcher__item__entry"
    });
    if (!sameFileWithPrevious) {
      const extension = (_h = (_g = item.file) == null ? void 0 : _g.extension) != null ? _h : "md";
      const titleDiv = createDiv({
        cls: [
          "another-quick-switcher__item__title",
          "another-quick-switcher__link__item__title_entry"
        ],
        text: (_j = (_i = item.file) == null ? void 0 : _i.basename) != null ? _j : item.displayLink,
        attr: {
          extension
        }
      });
      const isExcalidrawFile = isExcalidraw(item.file);
      if (extension !== "md" || isExcalidrawFile) {
        const extDiv = createDiv({
          cls: "another-quick-switcher__item__extension",
          text: isExcalidrawFile ? "excalidraw" : extension
        });
        titleDiv.appendChild(extDiv);
      }
      entryDiv.appendChild(titleDiv);
      itemDiv.appendChild(entryDiv);
      if (this.settings.showDirectory) {
        const directoryDiv = createDiv({
          cls: "another-quick-switcher__item__directory"
        });
        directoryDiv.insertAdjacentHTML("beforeend", FOLDER);
        const text = this.settings.showFullPathOfDirectory ? (_l = (_k = item.file) == null ? void 0 : _k.parent) == null ? void 0 : _l.path : (_n = (_m = item.file) == null ? void 0 : _m.parent) == null ? void 0 : _n.name;
        directoryDiv.appendText(` ${text}`);
        entryDiv.appendChild(directoryDiv);
        if (this.settings.showDirectoryAtNewLine) {
          itemDiv.appendChild(directoryDiv);
        }
      }
    }
    const descriptionsDiv = createDiv({
      cls: "another-quick-switcher__item__descriptions"
    });
    const descriptionDiv = createDiv({
      cls: "another-quick-switcher__link__item__description"
    });
    descriptionDiv.createSpan({
      text: item.line
    });
    if (item.order < 9) {
      const hotKeyGuide = createSpan({
        cls: "another-quick-switcher__link__item__hot-key-guide",
        text: `${item.order + 1}`
      });
      descriptionsDiv.appendChild(hotKeyGuide);
    }
    descriptionsDiv.appendChild(descriptionDiv);
    itemDiv.appendChild(descriptionsDiv);
    el.appendChild(itemDiv);
  }
  navigate(cb) {
    this.navQueue = this.navQueue.then(cb);
  }
  async chooseCurrentSuggestion(leaf, option = {}) {
    var _a, _b;
    const item = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem];
    if (!item) {
      return null;
    }
    if (!option.keepOpen) {
      this.close();
      this.navigate(() => this.isClosed);
    } else if (leaf === "same-tab") {
      (_b = this.stateToRestore) != null ? _b : this.stateToRestore = this.appHelper.captureState(this.initialLeaf);
    }
    this.navigate(
      () => this.appHelper.openFile(
        this.appHelper.getActiveFile(),
        {
          leafType: leaf,
          line: item.lineNumber - 1,
          inplace: option.keepOpen,
          preventDuplicateTabs: this.settings.preventDuplicateTabs
        },
        this.stateToRestore
      )
    );
    return this.appHelper.getActiveFile();
  }
  async onChooseSuggestion() {
    await this.chooseCurrentSuggestion("same-tab");
  }
  registerKeys(key, handler) {
    var _a;
    for (const x of (_a = this.settings.hotkeys.link[key]) != null ? _a : []) {
      this.scope.register(
        x.modifiers,
        normalizeKey(capitalizeFirstLetter(x.key)),
        (evt) => {
          if (!evt.isComposing) {
            evt.preventDefault();
            handler();
            return false;
          }
        }
      );
    }
  }
  setHotkeys() {
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Enter"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Escape"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Home"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "End"));
    const openNthMod = quickResultSelectionModifier(
      this.settings.userAltInsteadOfModForQuickResultSelection
    );
    if (!this.settings.hideHotkeyGuides) {
      this.setInstructions([
        { command: "[\u21B5]", purpose: "open" },
        { command: "[\u2191]", purpose: "up" },
        { command: "[\u2193]", purpose: "down" },
        { command: `[${openNthMod} 1~9]`, purpose: "open Nth" },
        ...createInstructions(this.settings.hotkeys.link)
      ]);
    }
    this.registerKeys("up", () => {
      document.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowUp" }));
    });
    this.registerKeys("down", () => {
      document.dispatchEvent(
        new KeyboardEvent("keydown", { key: "ArrowDown" })
      );
    });
    this.registerKeys("open", async () => {
      await this.chooseCurrentSuggestion("same-tab");
    });
    this.registerKeys("open in new tab", async () => {
      await this.chooseCurrentSuggestion("new-tab");
    });
    this.registerKeys("open in new pane (horizontal)", async () => {
      await this.chooseCurrentSuggestion("new-pane-horizontal");
    });
    this.registerKeys("open in new pane (vertical)", async () => {
      await this.chooseCurrentSuggestion("new-pane-vertical");
    });
    this.registerKeys("open in new window", async () => {
      await this.chooseCurrentSuggestion("new-window");
    });
    this.registerKeys("open in popup", async () => {
      await this.chooseCurrentSuggestion("popup");
    });
    this.registerKeys("open in new tab in background", async () => {
      await this.chooseCurrentSuggestion("new-tab-background", {
        keepOpen: true
      });
    });
    this.registerKeys("open all in new tabs", () => {
      this.close();
      if (this.chooser.values == null) {
        return;
      }
      const files = this.chooser.values.slice().reverse().map((x) => x.file).filter(isPresent);
      for (const x of files) {
        this.appHelper.openFile(x, {
          leafType: "new-tab-background",
          preventDuplicateTabs: this.settings.preventDuplicateTabs
        });
      }
    });
    this.registerKeys("show all results", () => {
      this.limit = Number.MAX_SAFE_INTEGER;
      this.inputEl.dispatchEvent(new Event("input"));
    });
    this.registerKeys("preview", async () => {
      await this.chooseCurrentSuggestion("same-tab", {
        keepOpen: true
      });
    });
    const modifierKey = this.settings.userAltInsteadOfModForQuickResultSelection ? "Alt" : "Mod";
    for (const n of [1, 2, 3, 4, 5, 6, 7, 8, 9]) {
      this.scope.register([modifierKey], String(n), (evt) => {
        this.chooser.setSelectedItem(n - 1, evt);
        this.chooser.useSelectedItem({});
        return false;
      });
    }
    this.registerKeys("dismiss", async () => {
      this.close();
    });
  }
};

// src/ui/MoveModal.ts
var import_moment = __toESM(require_moment());
var import_obsidian11 = require("obsidian");
function matchQuery3(item, query, matcher, isNormalizeAccentsDiacritics) {
  const qs = query.split("/");
  const folder = qs.pop();
  return qs.every(
    (dir) => {
      var _a;
      return smartIncludes(
        (_a = item.folder.parent) == null ? void 0 : _a.path,
        dir,
        isNormalizeAccentsDiacritics
      );
    }
  ) && matcher(item, folder);
}
function matchQueryAll3(item, queries, matcher, isNormalizeAccentsDiacritics) {
  return queries.every(
    (q) => matchQuery3(item, q, matcher, isNormalizeAccentsDiacritics)
  );
}
function stampMatchType2(item, queries, isNormalizeAccentsDiacritics) {
  if (matchQueryAll3(
    item,
    queries,
    (item2, query) => smartStartsWith(item2.folder.name, query, isNormalizeAccentsDiacritics),
    isNormalizeAccentsDiacritics
  )) {
    return { ...item, matchType: "prefix-name" };
  }
  if (matchQueryAll3(
    item,
    queries,
    (item2, query) => smartIncludes(item2.folder.name, query, isNormalizeAccentsDiacritics),
    isNormalizeAccentsDiacritics
  )) {
    return { ...item, matchType: "name" };
  }
  if (matchQueryAll3(
    item,
    queries,
    (item2, query) => smartIncludes(item2.folder.path, query, isNormalizeAccentsDiacritics),
    isNormalizeAccentsDiacritics
  )) {
    return { ...item, matchType: "directory" };
  }
  return item;
}
var MoveModal = class extends import_obsidian11.SuggestModal {
  constructor(app, settings) {
    super(app);
    this.modalEl.addClass("another-quick-switcher__modal-prompt");
    this.appHelper = new AppHelper(app);
    this.settings = settings;
    this.setHotkeys();
    this.originItems = this.appHelper.getFolders().filter((x) => !x.isRoot()).map((x) => ({
      folder: x
    }));
    this.filteredItems = excludeItems(
      this.originItems,
      this.settings.moveFileExcludePrefixPathPatterns,
      (x) => x.folder.path
    );
  }
  getSuggestions(query) {
    const qs = query.split(" ").filter((x) => x);
    return this.filteredItems.map(
      (x) => stampMatchType2(x, qs, this.settings.normalizeAccentsAndDiacritics)
    ).filter((x) => x.matchType).sort(sorter((x) => x.matchType === "directory" ? 1 : 0)).sort(
      sorter(
        (x) => x.matchType === "prefix-name" ? 1e3 - x.folder.name.length : 0,
        "desc"
      )
    ).slice(0, 10);
  }
  renderSuggestion(item, el) {
    var _a;
    const itemDiv = createDiv({
      cls: [
        "another-quick-switcher__item",
        "another-quick-switcher__directory_item"
      ]
    });
    const entryDiv = createDiv({
      cls: "another-quick-switcher__item__entry"
    });
    const folderDiv = createDiv({
      cls: "another-quick-switcher__item__title",
      text: item.folder.name
    });
    entryDiv.appendChild(folderDiv);
    const directoryDiv = createDiv({
      cls: "another-quick-switcher__item__directory"
    });
    directoryDiv.insertAdjacentHTML("beforeend", FOLDER);
    directoryDiv.appendText(` ${(_a = item.folder.parent) == null ? void 0 : _a.name}`);
    entryDiv.appendChild(directoryDiv);
    itemDiv.appendChild(entryDiv);
    el.appendChild(itemDiv);
  }
  async onChooseSuggestion(item) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return;
    }
    let newPath = `${item.folder.path}/${activeFile.name}`;
    if (await this.appHelper.exists(newPath)) {
      const newName = `${activeFile.basename}.${(0, import_moment.default)().format("YYYYMMDD_HHmmss_SSS")}.${activeFile.extension}`;
      newPath = `${item.folder.path}/${newName}`;
      new import_obsidian11.Notice(
        `Since a file with the same name already exists in the destination directory, it will be moved and renamed ${newName}`
      );
    }
    await this.app.fileManager.renameFile(activeFile, newPath);
  }
  registerKeys(key, handler) {
    var _a;
    for (const x of (_a = this.settings.hotkeys.move[key]) != null ? _a : []) {
      this.scope.register(x.modifiers, x.key.toUpperCase(), (evt) => {
        evt.preventDefault();
        handler();
        return false;
      });
    }
  }
  setHotkeys() {
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Escape"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "Home"));
    this.scope.unregister(this.scope.keys.find((x) => x.key === "End"));
    if (!this.settings.hideHotkeyGuides) {
      this.setInstructions([
        { command: "[\u21B5]", purpose: "move to" },
        { command: "[\u2191]", purpose: "up" },
        { command: "[\u2193]", purpose: "down" },
        ...createInstructions(this.settings.hotkeys.move)
      ]);
    }
    this.registerKeys("up", () => {
      document.dispatchEvent(new KeyboardEvent("keydown", { key: "ArrowUp" }));
    });
    this.registerKeys("down", () => {
      document.dispatchEvent(
        new KeyboardEvent("keydown", { key: "ArrowDown" })
      );
    });
    this.registerKeys("open in default app", () => {
      var _a, _b;
      const folder = (_b = (_a = this.chooser.values) == null ? void 0 : _a[this.chooser.selectedItem]) == null ? void 0 : _b.folder;
      if (!folder) {
        return;
      }
      this.appHelper.openFolderInDefaultApp(folder);
      this.close();
    });
    this.registerKeys("dismiss", async () => {
      this.close();
    });
  }
};

// src/commands.ts
var SEARCH_COMMAND_PREFIX = "search-command";
function showSearchDialog(app, settings, command) {
  var _a, _b, _c, _d;
  const activeFileLeaf = (_b = (_a = app.workspace.getActiveViewOfType(import_obsidian12.FileView)) == null ? void 0 : _a.leaf) != null ? _b : null;
  const editor = (_d = (_c = app.workspace.getActiveViewOfType(import_obsidian12.MarkdownView)) == null ? void 0 : _c.editor) != null ? _d : null;
  const modal = new AnotherQuickSwitcherModal({
    app,
    settings,
    command,
    originFile: app.workspace.getActiveFile(),
    inputQuery: settings.useSelectionWordsAsDefaultInputQuery ? (editor == null ? void 0 : editor.getSelection()) || null : null,
    navigationHistories: [],
    currentNavigationHistoryIndex: 0,
    stackHistory: true,
    initialLeaf: activeFileLeaf
  });
  modal.open();
}
function showFolderDialog(app, settings) {
  const modal = new FolderModal(app, settings);
  modal.open();
}
function showMoveDialog(app, settings) {
  if (!app.workspace.getActiveFile()) {
    return;
  }
  const modal = new MoveModal(app, settings);
  modal.open();
}
async function showGrepDialog(app, settings) {
  var _a, _b;
  if (!import_obsidian12.Platform.isDesktop) {
    new import_obsidian12.Notice("Grep is not supported on mobile.");
    return;
  }
  if (!await existsRg(settings.ripgrepCommand)) {
    new import_obsidian12.Notice(
      `"${settings.ripgrepCommand}" was not working as a ripgrep command. If you have not installed ripgrep yet, please install it.`
    );
    return;
  }
  const activeFileLeaf = (_b = (_a = app.workspace.getActiveViewOfType(import_obsidian12.FileView)) == null ? void 0 : _a.leaf) != null ? _b : null;
  const modal = new GrepModal(app, settings, activeFileLeaf);
  modal.open();
}
async function showBacklinkDialog(app, settings) {
  var _a, _b;
  if (!app.workspace.getActiveFile()) {
    return;
  }
  const activeFileLeaf = (_b = (_a = app.workspace.getActiveViewOfType(import_obsidian12.FileView)) == null ? void 0 : _a.leaf) != null ? _b : null;
  const modal = new BacklinkModal(app, settings, activeFileLeaf);
  await modal.init();
  modal.open();
}
async function showLinkDialog(app, settings) {
  var _a, _b;
  if (!app.workspace.getActiveFile()) {
    return;
  }
  const activeFileLeaf = (_b = (_a = app.workspace.getActiveViewOfType(import_obsidian12.FileView)) == null ? void 0 : _a.leaf) != null ? _b : null;
  const modal = new LinkModal(app, settings, activeFileLeaf);
  await modal.init();
  modal.open();
}
async function showInFileDialog(app, settings) {
  var _a, _b;
  if (!app.workspace.getActiveFile()) {
    return;
  }
  const activeFileLeaf = (_b = (_a = app.workspace.getActiveViewOfType(import_obsidian12.FileView)) == null ? void 0 : _a.leaf) != null ? _b : null;
  const modal = new InFileModal(app, settings, activeFileLeaf);
  await modal.init();
  modal.open();
}
function showHeaderDialog(app, settings, floating) {
  if (!app.workspace.getActiveFile()) {
    return;
  }
  const modal = new HeaderModal(app, settings, floating);
  modal.open();
}
function createCommands(app, settings) {
  return [
    {
      id: "header-search-in-file",
      name: "Header search in file",
      checkCallback: (checking) => {
        if (checking) {
          return Boolean(app.workspace.getActiveFile());
        }
        showHeaderDialog(app, settings, false);
      }
    },
    {
      id: "header-floating-search-in-file",
      name: "Header floating search in file",
      checkCallback: (checking) => {
        if (checking) {
          return Boolean(app.workspace.getActiveFile());
        }
        showHeaderDialog(app, settings, true);
      }
    },
    {
      id: "folder",
      name: "Reveal a folder in the file tree",
      hotkeys: [],
      callback: () => {
        showFolderDialog(app, settings);
      }
    },
    {
      id: "move",
      name: "Move file to another folder",
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "m" }],
      checkCallback: (checking) => {
        if (checking) {
          return Boolean(app.workspace.getActiveFile());
        }
        showMoveDialog(app, settings);
      }
    },
    {
      id: "grep",
      name: "Grep",
      hotkeys: [],
      checkCallback: (checking) => {
        if (checking) {
          return import_obsidian12.Platform.isDesktop;
        }
        showGrepDialog(app, settings);
      }
    },
    {
      id: "backlink",
      name: "Backlink search",
      hotkeys: [],
      checkCallback: (checking) => {
        if (checking) {
          return Boolean(app.workspace.getActiveFile());
        }
        showBacklinkDialog(app, settings);
      }
    },
    {
      id: "link",
      name: "Link search",
      hotkeys: [],
      checkCallback: (checking) => {
        if (checking) {
          return Boolean(app.workspace.getActiveFile());
        }
        showLinkDialog(app, settings);
      }
    },
    {
      id: "in-file-search",
      name: "In file search",
      hotkeys: [],
      checkCallback: (checking) => {
        if (checking) {
          return Boolean(app.workspace.getActiveFile());
        }
        showInFileDialog(app, settings);
      }
    },
    ...settings.searchCommands.map((command) => {
      return {
        id: `${SEARCH_COMMAND_PREFIX}_${command.name.replace(/ /g, "-").toLowerCase()}`,
        name: command.name,
        hotkeys: [],
        callback: () => {
          showSearchDialog(app, settings, command);
        }
      };
    })
  ];
}

// src/main.ts
var AnotherQuickSwitcher = class extends import_obsidian13.Plugin {
  async onload() {
    this.appHelper = new AppHelper(this.app);
    await this.loadSettings();
    this.addSettingTab(new AnotherQuickSwitcherSettingTab(this.app, this));
    if (this.appHelper.isCacheInitialized()) {
      this.reloadCommands();
    } else {
      const cacheResolvedRef = this.app.metadataCache.on(
        "resolved",
        async () => {
          this.reloadCommands();
          this.app.metadataCache.offref(cacheResolvedRef);
        }
      );
    }
  }
  reloadCommands() {
    const commandIds = this.appHelper.getCommandIds(this.manifest.id);
    for (const x of commandIds) {
      this.appHelper.removeCommand(x);
    }
    const commands = createCommands(this.app, this.settings);
    for (const x of commands) {
      this.addCommand(x);
    }
  }
  async loadSettings() {
    const currentSettings = await this.loadData();
    this.settings = import_ts_deepmerge2.default.withOptions(
      { mergeArrays: false },
      DEFAULT_SETTINGS,
      currentSettings != null ? currentSettings : {}
    );
    this.settings.searchCommands.forEach((_, i) => {
      this.settings.searchCommands[i] = import_ts_deepmerge2.default.withOptions(
        { mergeArrays: false },
        createDefaultSearchCommand(),
        {
          ...this.settings.searchCommands[i]
        }
      );
      if (this.settings.searchCommands[i].searchTarget === "markdown") {
        this.settings.searchCommands[i].searchTarget = "file";
      }
    });
    const defaultHotkeys = createDefaultHotkeys();
    const defaultDialogKeys = Object.keys(defaultHotkeys);
    for (const dialogKey of defaultDialogKeys) {
      const dialogKeys = Object.keys(this.settings.hotkeys[dialogKey]);
      for (const k of dialogKeys) {
        if (!(k in defaultHotkeys[dialogKey])) {
          delete this.settings.hotkeys[dialogKey][k];
        }
      }
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
